import { EventEmitter, Component, ElementRef, Input, Output, SkipSelf, Optional, forwardRef, Host, ContentChild, ContentChildren, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import View from 'ol/View';
import Map from 'ol/Map';
import 'ol/extent';
import 'ol/coordinate';
import { Graticule, VectorTile as VectorTile$1, Feature, Overlay } from 'ol';
import { Style, Circle as Circle$1, Text, Stroke, Icon, Fill } from 'ol/style';
import { __extends } from 'tslib';
import { Group, Image, Tile, Vector, VectorTile } from 'ol/layer';
import { Raster, XYZ, OSM, BingMaps, Vector as Vector$1, Cluster, WMTS as WMTS$1, TileWMS, TileJSON, ImageStatic, ImageWMS, ImageArcGISRest, UTFGrid } from 'ol/source';
import { createXYZ } from 'ol/tilegrid';
import TileGrid from 'ol/tilegrid/TileGrid';
import 'ol/source/Raster';
import 'ol/Tile';
import 'ol/source/Source';
import 'ol/format/Feature';
import 'ol/source/Vector';
import WMTS from 'ol/tilegrid/WMTS';
import { transform } from 'ol/proj';
import { GeoJSON, MVT } from 'ol/format';
import 'ol/Image';
import 'ol/size';
import { Circle, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon } from 'ol/geom';
import 'ol/color';
import 'ol/style/IconAnchorUnits';
import 'ol/style/IconOrigin';
import { defaults, Control, Attribution, FullScreen, OverviewMap, Rotate, ScaleLine, Zoom, ZoomSlider, ZoomToExtent } from 'ol/control';
import 'ol/control/Attribution';
import 'ol/control/Rotate';
import 'ol/control/Zoom';
import MousePosition from 'ol/control/MousePosition';
import { defaults as defaults$1, DoubleClickZoom, DragAndDrop, DragBox, DragPan, DragRotate, DragRotateAndZoom, DragZoom, MouseWheelZoom, PinchZoom, Draw, Select, Modify, Translate } from 'ol/interaction';
import 'ol/events/condition';
import 'ol/interaction/DragBox';
import 'ol/Kinetic';
import 'ol/geom/GeometryType';
import 'ol/interaction/Draw';
import 'ol/interaction/Select';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MapComponent = /** @class */ (function () {
    function MapComponent(host) {
        this.host = host;
        this.componentType = 'map';
        this.width = '100%';
        this.height = '100%';
        // we pass empty arrays to not get default controls/interactions because we have our own directives
        this.controls = [];
        this.interactions = [];
        this.olClick = new EventEmitter();
        this.dblClick = new EventEmitter();
        this.moveStart = new EventEmitter();
        this.moveEnd = new EventEmitter();
        this.pointerDrag = new EventEmitter();
        this.pointerMove = new EventEmitter();
        this.onpostrender = new EventEmitter();
        this.postRender = new EventEmitter();
        this.onprerender = new EventEmitter();
        this.propertyChange = new EventEmitter();
        this.singleClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    MapComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // console.log('creating ol.Map instance with:', this);
        this.instance = new Map(this);
        this.instance.setTarget(this.host.nativeElement.firstElementChild);
        this.instance.on('click', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.olClick.emit(event); }));
        this.instance.on('dblclick', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.dblClick.emit(event); }));
        this.instance.on('movestart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.moveStart.emit(event); }));
        this.instance.on('moveend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.moveEnd.emit(event); }));
        this.instance.on('pointerdrag', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.pointerDrag.emit(event); }));
        this.instance.on('pointermove', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.pointerMove.emit(event); }));
        this.instance.on('postrender', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onpostrender.emit(event); }));
        this.instance.on('postrender', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.postRender.emit(event); }));
        this.instance.on('prerender', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onprerender.emit(event); }));
        this.instance.on('propertychange', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.propertyChange.emit(event); }));
        this.instance.on('singleclick', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.singleClick.emit(event); }));
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    MapComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var properties = {};
        if (!this.instance) {
            return;
        }
        for (var key in changes) {
            if (changes.hasOwnProperty(key)) {
                properties[key] = changes[key].currentValue;
            }
        }
        // console.log('changes detected in aol-map, setting new properties: ', properties);
        this.instance.setProperties(properties, false);
    };
    /**
     * @return {?}
     */
    MapComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.instance.updateSize();
    };
    MapComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-map',
                    template: "\n    <div [style.width]=\"width\" [style.height]=\"height\"></div>\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    MapComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    MapComponent.propDecorators = {
        width: [{ type: Input }],
        height: [{ type: Input }],
        pixelRatio: [{ type: Input }],
        keyboardEventTarget: [{ type: Input }],
        loadTilesWhileAnimating: [{ type: Input }],
        loadTilesWhileInteracting: [{ type: Input }],
        logo: [{ type: Input }],
        renderer: [{ type: Input }],
        olClick: [{ type: Output }],
        dblClick: [{ type: Output }],
        moveStart: [{ type: Output }],
        moveEnd: [{ type: Output }],
        pointerDrag: [{ type: Output }],
        pointerMove: [{ type: Output }],
        onpostrender: [{ type: Output }],
        postRender: [{ type: Output }],
        onprerender: [{ type: Output }],
        propertyChange: [{ type: Output }],
        singleClick: [{ type: Output }]
    };
    return MapComponent;
}());
if (false) {
    /** @type {?} */
    MapComponent.prototype.instance;
    /** @type {?} */
    MapComponent.prototype.componentType;
    /** @type {?} */
    MapComponent.prototype.width;
    /** @type {?} */
    MapComponent.prototype.height;
    /** @type {?} */
    MapComponent.prototype.pixelRatio;
    /** @type {?} */
    MapComponent.prototype.keyboardEventTarget;
    /** @type {?} */
    MapComponent.prototype.loadTilesWhileAnimating;
    /** @type {?} */
    MapComponent.prototype.loadTilesWhileInteracting;
    /** @type {?} */
    MapComponent.prototype.logo;
    /** @type {?} */
    MapComponent.prototype.renderer;
    /** @type {?} */
    MapComponent.prototype.olClick;
    /** @type {?} */
    MapComponent.prototype.dblClick;
    /** @type {?} */
    MapComponent.prototype.moveStart;
    /** @type {?} */
    MapComponent.prototype.moveEnd;
    /** @type {?} */
    MapComponent.prototype.pointerDrag;
    /** @type {?} */
    MapComponent.prototype.pointerMove;
    /** @type {?} */
    MapComponent.prototype.onpostrender;
    /** @type {?} */
    MapComponent.prototype.postRender;
    /** @type {?} */
    MapComponent.prototype.onprerender;
    /** @type {?} */
    MapComponent.prototype.propertyChange;
    /** @type {?} */
    MapComponent.prototype.singleClick;
    /** @type {?} */
    MapComponent.prototype.controls;
    /** @type {?} */
    MapComponent.prototype.interactions;
    /**
     * @type {?}
     * @private
     */
    MapComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ViewComponent = /** @class */ (function () {
    function ViewComponent(host) {
        this.host = host;
        this.componentType = 'view';
        this.zoomAnimation = false;
        this.changeZoom = new EventEmitter();
        this.changeResolution = new EventEmitter();
        this.changeCenter = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ViewComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // console.log('creating ol.View instance with: ', this);
        this.instance = new View(this);
        this.host.instance.setView(this.instance);
        this.instance.on('change:zoom', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.changeZoom.emit(event); }));
        this.instance.on('change:resolution', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.changeResolution.emit(event); }));
        this.instance.on('change:center', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.changeCenter.emit(event); }));
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ViewComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var properties = {};
        if (!this.instance) {
            return;
        }
        for (var key in changes) {
            if (changes.hasOwnProperty(key)) {
                switch (key) {
                    case 'zoom':
                        /** Work-around: setting the zoom via setProperties does not work. */
                        if (this.zoomAnimation) {
                            this.instance.animate({ zoom: changes[key].currentValue });
                        }
                        else {
                            this.instance.setZoom(changes[key].currentValue);
                        }
                        break;
                    case 'projection':
                        this.instance = new View(this);
                        this.host.instance.setView(this.instance);
                        break;
                    default:
                        break;
                }
                properties[key] = changes[key].currentValue;
            }
        }
        // console.log('changes detected in aol-view, setting new properties: ', properties);
        this.instance.setProperties(properties, false);
    };
    /**
     * @return {?}
     */
    ViewComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // console.log('removing aol-view');
    };
    ViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-view',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    ViewComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    ViewComponent.propDecorators = {
        constrainRotation: [{ type: Input }],
        enableRotation: [{ type: Input }],
        extent: [{ type: Input }],
        maxResolution: [{ type: Input }],
        minResolution: [{ type: Input }],
        maxZoom: [{ type: Input }],
        minZoom: [{ type: Input }],
        resolution: [{ type: Input }],
        resolutions: [{ type: Input }],
        rotation: [{ type: Input }],
        zoom: [{ type: Input }],
        zoomFactor: [{ type: Input }],
        center: [{ type: Input }],
        projection: [{ type: Input }],
        zoomAnimation: [{ type: Input }],
        changeZoom: [{ type: Output }],
        changeResolution: [{ type: Output }],
        changeCenter: [{ type: Output }]
    };
    return ViewComponent;
}());
if (false) {
    /** @type {?} */
    ViewComponent.prototype.instance;
    /** @type {?} */
    ViewComponent.prototype.componentType;
    /** @type {?} */
    ViewComponent.prototype.constrainRotation;
    /** @type {?} */
    ViewComponent.prototype.enableRotation;
    /** @type {?} */
    ViewComponent.prototype.extent;
    /** @type {?} */
    ViewComponent.prototype.maxResolution;
    /** @type {?} */
    ViewComponent.prototype.minResolution;
    /** @type {?} */
    ViewComponent.prototype.maxZoom;
    /** @type {?} */
    ViewComponent.prototype.minZoom;
    /** @type {?} */
    ViewComponent.prototype.resolution;
    /** @type {?} */
    ViewComponent.prototype.resolutions;
    /** @type {?} */
    ViewComponent.prototype.rotation;
    /** @type {?} */
    ViewComponent.prototype.zoom;
    /** @type {?} */
    ViewComponent.prototype.zoomFactor;
    /** @type {?} */
    ViewComponent.prototype.center;
    /** @type {?} */
    ViewComponent.prototype.projection;
    /** @type {?} */
    ViewComponent.prototype.zoomAnimation;
    /** @type {?} */
    ViewComponent.prototype.changeZoom;
    /** @type {?} */
    ViewComponent.prototype.changeResolution;
    /** @type {?} */
    ViewComponent.prototype.changeCenter;
    /**
     * @type {?}
     * @private
     */
    ViewComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GraticuleComponent = /** @class */ (function () {
    function GraticuleComponent(map) {
        this.map = map;
        this.componentType = 'graticule';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    GraticuleComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var properties = {};
        if (!this.instance) {
            return;
        }
        for (var key in changes) {
            if (changes.hasOwnProperty(key)) {
                properties[key] = changes[key].currentValue;
            }
        }
        if (properties) {
            this.instance = new Graticule(properties);
        }
        this.instance.setMap(this.map.instance);
    };
    /**
     * @return {?}
     */
    GraticuleComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.instance = new Graticule({
            strokeStyle: this.strokeStyle,
            showLabels: this.showLabels,
            lonLabelPosition: this.lonLabelPosition,
            latLabelPosition: this.latLabelPosition,
        });
        this.instance.setMap(this.map.instance);
    };
    /**
     * @return {?}
     */
    GraticuleComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.instance.setMap(null);
    };
    GraticuleComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-graticule',
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    GraticuleComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    GraticuleComponent.propDecorators = {
        strokeStyle: [{ type: Input }],
        showLabels: [{ type: Input }],
        lonLabelPosition: [{ type: Input }],
        latLabelPosition: [{ type: Input }]
    };
    return GraticuleComponent;
}());
if (false) {
    /** @type {?} */
    GraticuleComponent.prototype.instance;
    /** @type {?} */
    GraticuleComponent.prototype.componentType;
    /** @type {?} */
    GraticuleComponent.prototype.strokeStyle;
    /** @type {?} */
    GraticuleComponent.prototype.showLabels;
    /** @type {?} */
    GraticuleComponent.prototype.lonLabelPosition;
    /** @type {?} */
    GraticuleComponent.prototype.latLabelPosition;
    /**
     * @type {?}
     * @private
     */
    GraticuleComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var LayerComponent = /** @class */ (function () {
    function LayerComponent(host) {
        this.host = host;
        this.componentType = 'layer';
    }
    /**
     * @return {?}
     */
    LayerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.prerender !== null && this.prerender !== undefined) {
            this.instance.on('prerender', this.prerender);
        }
        if (this.postrender !== null && this.postrender !== undefined) {
            this.instance.on('postrender', this.postrender);
        }
        this.host.instance.getLayers().push(this.instance);
    };
    /**
     * @return {?}
     */
    LayerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.host.instance.getLayers().remove(this.instance);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    LayerComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var properties = {};
        if (!this.instance) {
            return;
        }
        for (var key in changes) {
            if (changes.hasOwnProperty(key)) {
                properties[key] = changes[key].currentValue;
                if (key === 'prerender') {
                    this.instance.un('prerender', changes[key].previousValue);
                    this.instance.on('prerender', changes[key].currentValue);
                }
                if (key === 'postrender') {
                    this.instance.un('postrender', changes[key].previousValue);
                    this.instance.on('postrender', changes[key].currentValue);
                }
            }
        }
        // console.log('changes detected in aol-layer, setting new properties: ', properties);
        this.instance.setProperties(properties, false);
    };
    LayerComponent.propDecorators = {
        opacity: [{ type: Input }],
        visible: [{ type: Input }],
        extent: [{ type: Input }],
        zIndex: [{ type: Input }],
        minResolution: [{ type: Input }],
        maxResolution: [{ type: Input }],
        prerender: [{ type: Input }],
        postrender: [{ type: Input }]
    };
    return LayerComponent;
}());
if (false) {
    /** @type {?} */
    LayerComponent.prototype.instance;
    /** @type {?} */
    LayerComponent.prototype.componentType;
    /** @type {?} */
    LayerComponent.prototype.opacity;
    /** @type {?} */
    LayerComponent.prototype.visible;
    /** @type {?} */
    LayerComponent.prototype.extent;
    /** @type {?} */
    LayerComponent.prototype.zIndex;
    /** @type {?} */
    LayerComponent.prototype.minResolution;
    /** @type {?} */
    LayerComponent.prototype.maxResolution;
    /** @type {?} */
    LayerComponent.prototype.prerender;
    /** @type {?} */
    LayerComponent.prototype.postrender;
    /**
     * @type {?}
     * @protected
     */
    LayerComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerGroupComponent = /** @class */ (function (_super) {
    __extends(LayerGroupComponent, _super);
    function LayerGroupComponent(map, group) {
        return _super.call(this, group || map) || this;
    }
    /**
     * @return {?}
     */
    LayerGroupComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // console.log(`creating ol.layer.Group instance with:`, this);
        this.instance = new Group(this);
        _super.prototype.ngOnInit.call(this);
    };
    LayerGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-layer-group',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    LayerGroupComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: LayerGroupComponent, decorators: [{ type: SkipSelf }, { type: Optional }] }
    ]; };
    return LayerGroupComponent;
}(LayerComponent));
if (false) {
    /** @type {?} */
    LayerGroupComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerImageComponent = /** @class */ (function (_super) {
    __extends(LayerImageComponent, _super);
    function LayerImageComponent(map, group) {
        return _super.call(this, group || map) || this;
    }
    /**
     * @return {?}
     */
    LayerImageComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new Image(this);
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    LayerImageComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
    };
    LayerImageComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-layer-image',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    LayerImageComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: LayerGroupComponent, decorators: [{ type: Optional }] }
    ]; };
    LayerImageComponent.propDecorators = {
        opacity: [{ type: Input }],
        visible: [{ type: Input }],
        extent: [{ type: Input }],
        minResolution: [{ type: Input }],
        maxResolution: [{ type: Input }],
        zIndex: [{ type: Input }]
    };
    return LayerImageComponent;
}(LayerComponent));
if (false) {
    /** @type {?} */
    LayerImageComponent.prototype.source;
    /** @type {?} */
    LayerImageComponent.prototype.opacity;
    /** @type {?} */
    LayerImageComponent.prototype.visible;
    /** @type {?} */
    LayerImageComponent.prototype.extent;
    /** @type {?} */
    LayerImageComponent.prototype.minResolution;
    /** @type {?} */
    LayerImageComponent.prototype.maxResolution;
    /** @type {?} */
    LayerImageComponent.prototype.zIndex;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerTileComponent = /** @class */ (function (_super) {
    __extends(LayerTileComponent, _super);
    function LayerTileComponent(map, group) {
        return _super.call(this, group || map) || this;
    }
    /**
     * @return {?}
     */
    LayerTileComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // console.log('creating ol.layer.Tile instance with:', this);
        this.instance = new Tile(this);
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    LayerTileComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
    };
    LayerTileComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-layer-tile',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    LayerTileComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: LayerGroupComponent, decorators: [{ type: Optional }] }
    ]; };
    LayerTileComponent.propDecorators = {
        preload: [{ type: Input }],
        useInterimTilesOnError: [{ type: Input }]
    };
    return LayerTileComponent;
}(LayerComponent));
if (false) {
    /** @type {?} */
    LayerTileComponent.prototype.source;
    /** @type {?} */
    LayerTileComponent.prototype.preload;
    /** @type {?} */
    LayerTileComponent.prototype.useInterimTilesOnError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerVectorComponent = /** @class */ (function (_super) {
    __extends(LayerVectorComponent, _super);
    function LayerVectorComponent(map, group) {
        return _super.call(this, group || map) || this;
    }
    /**
     * @return {?}
     */
    LayerVectorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // console.log('creating ol.layer.Vector instance with:', this);
        this.instance = new Vector(this);
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    LayerVectorComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
    };
    LayerVectorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-layer-vector',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    LayerVectorComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: LayerGroupComponent, decorators: [{ type: Optional }] }
    ]; };
    LayerVectorComponent.propDecorators = {
        renderBuffer: [{ type: Input }],
        style: [{ type: Input }],
        updateWhileAnimating: [{ type: Input }],
        updateWhileInteracting: [{ type: Input }]
    };
    return LayerVectorComponent;
}(LayerComponent));
if (false) {
    /** @type {?} */
    LayerVectorComponent.prototype.source;
    /** @type {?} */
    LayerVectorComponent.prototype.renderBuffer;
    /** @type {?} */
    LayerVectorComponent.prototype.style;
    /** @type {?} */
    LayerVectorComponent.prototype.updateWhileAnimating;
    /** @type {?} */
    LayerVectorComponent.prototype.updateWhileInteracting;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerVectorTileComponent = /** @class */ (function (_super) {
    __extends(LayerVectorTileComponent, _super);
    function LayerVectorTileComponent(map, group) {
        return _super.call(this, group || map) || this;
    }
    /**
     * @return {?}
     */
    LayerVectorTileComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // console.log('creating ol.layer.VectorTile instance with:', this);
        this.instance = new VectorTile(this);
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    LayerVectorTileComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
    };
    LayerVectorTileComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-layer-vectortile',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    LayerVectorTileComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: LayerGroupComponent, decorators: [{ type: Optional }] }
    ]; };
    LayerVectorTileComponent.propDecorators = {
        renderBuffer: [{ type: Input }],
        renderMode: [{ type: Input }],
        renderOrder: [{ type: Input }],
        style: [{ type: Input }],
        updateWhileAnimating: [{ type: Input }],
        updateWhileInteracting: [{ type: Input }],
        visible: [{ type: Input }]
    };
    return LayerVectorTileComponent;
}(LayerComponent));
if (false) {
    /** @type {?} */
    LayerVectorTileComponent.prototype.renderBuffer;
    /** @type {?} */
    LayerVectorTileComponent.prototype.renderMode;
    /** @type {?} */
    LayerVectorTileComponent.prototype.renderOrder;
    /** @type {?} */
    LayerVectorTileComponent.prototype.style;
    /** @type {?} */
    LayerVectorTileComponent.prototype.updateWhileAnimating;
    /** @type {?} */
    LayerVectorTileComponent.prototype.updateWhileInteracting;
    /** @type {?} */
    LayerVectorTileComponent.prototype.visible;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceComponent = /** @class */ (function () {
    function SourceComponent(host, raster) {
        this.host = host;
        this.raster = raster;
        this.componentType = 'source';
    }
    /**
     * @return {?}
     */
    SourceComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.host && this.host.instance) {
            this.host.instance.setSource(null);
        }
        if (this.raster) {
            this.raster.sources = [];
        }
    };
    /**
     * @protected
     * @param {?} s
     * @return {?}
     */
    SourceComponent.prototype._register = /**
     * @protected
     * @param {?} s
     * @return {?}
     */
    function (s) {
        if (this.host) {
            this.host.instance.setSource(s);
        }
        if (this.raster) {
            this.raster.sources = [s];
            this.raster.init();
        }
    };
    SourceComponent.propDecorators = {
        attributions: [{ type: Input }]
    };
    return SourceComponent;
}());
if (false) {
    /** @type {?} */
    SourceComponent.prototype.instance;
    /** @type {?} */
    SourceComponent.prototype.componentType;
    /** @type {?} */
    SourceComponent.prototype.attributions;
    /**
     * @type {?}
     * @protected
     */
    SourceComponent.prototype.host;
    /**
     * @type {?}
     * @protected
     */
    SourceComponent.prototype.raster;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TileGridComponent = /** @class */ (function () {
    function TileGridComponent() {
    }
    /**
     * @return {?}
     */
    TileGridComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.resolutions) {
            this.instance = createXYZ(this);
        }
        else {
            this.instance = new TileGrid(this);
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    TileGridComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.resolutions) {
            this.instance = createXYZ(this);
        }
        else {
            this.instance = new TileGrid(this);
        }
    };
    TileGridComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-tilegrid',
                    template: ''
                }] }
    ];
    TileGridComponent.propDecorators = {
        extent: [{ type: Input }],
        maxZoom: [{ type: Input }],
        minZoom: [{ type: Input }],
        tileSize: [{ type: Input }],
        origin: [{ type: Input }],
        resolutions: [{ type: Input }]
    };
    return TileGridComponent;
}());
if (false) {
    /** @type {?} */
    TileGridComponent.prototype.instance;
    /** @type {?} */
    TileGridComponent.prototype.extent;
    /** @type {?} */
    TileGridComponent.prototype.maxZoom;
    /** @type {?} */
    TileGridComponent.prototype.minZoom;
    /** @type {?} */
    TileGridComponent.prototype.tileSize;
    /** @type {?} */
    TileGridComponent.prototype.origin;
    /** @type {?} */
    TileGridComponent.prototype.resolutions;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceRasterComponent = /** @class */ (function (_super) {
    __extends(SourceRasterComponent, _super);
    function SourceRasterComponent(layer) {
        var _this = _super.call(this, layer) || this;
        _this.beforeOperations = new EventEmitter();
        _this.afterOperations = new EventEmitter();
        _this.sources = [];
        return _this;
    }
    /**
     * @return {?}
     */
    SourceRasterComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.init();
    };
    /**
     * @return {?}
     */
    SourceRasterComponent.prototype.init = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance = new Raster(this);
        this.instance.on('beforeoperations', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.beforeOperations.emit(event); }));
        this.instance.on('afteroperations', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.afterOperations.emit(event); }));
        this._register(this.instance);
    };
    SourceRasterComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-raster',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [
                        {
                            provide: SourceComponent,
                            useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceRasterComponent; })),
                        },
                    ]
                }] }
    ];
    /** @nocollapse */
    SourceRasterComponent.ctorParameters = function () { return [
        { type: LayerImageComponent, decorators: [{ type: Host }] }
    ]; };
    SourceRasterComponent.propDecorators = {
        operation: [{ type: Input }],
        threads: [{ type: Input }],
        lib: [{ type: Input }],
        operationType: [{ type: Input }],
        beforeOperations: [{ type: Output }],
        afterOperations: [{ type: Output }]
    };
    return SourceRasterComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceRasterComponent.prototype.instance;
    /** @type {?} */
    SourceRasterComponent.prototype.operation;
    /** @type {?} */
    SourceRasterComponent.prototype.threads;
    /** @type {?} */
    SourceRasterComponent.prototype.lib;
    /** @type {?} */
    SourceRasterComponent.prototype.operationType;
    /** @type {?} */
    SourceRasterComponent.prototype.beforeOperations;
    /** @type {?} */
    SourceRasterComponent.prototype.afterOperations;
    /** @type {?} */
    SourceRasterComponent.prototype.sources;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceXYZComponent = /** @class */ (function (_super) {
    __extends(SourceXYZComponent, _super);
    function SourceXYZComponent(layer, raster) {
        var _this = _super.call(this, layer, raster) || this;
        _this.tileLoadStart = new EventEmitter();
        _this.tileLoadEnd = new EventEmitter();
        _this.tileLoadError = new EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    SourceXYZComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.tileGridXYZ) {
            this.tileGrid = this.tileGridXYZ.instance;
        }
        this.init();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SourceXYZComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var properties = {};
        if (!this.instance) {
            return;
        }
        for (var key in changes) {
            if (changes.hasOwnProperty(key)) {
                properties[key] = changes[key].currentValue;
            }
        }
        this.instance.setProperties(properties, false);
        if (changes.hasOwnProperty('url')) {
            this.init();
        }
    };
    /**
     * @return {?}
     */
    SourceXYZComponent.prototype.init = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance = new XYZ(this);
        this.instance.on('tileloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.tileLoadStart.emit(event); }));
        this.instance.on('tileloadend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.tileLoadEnd.emit(event); }));
        this.instance.on('tileloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.tileLoadError.emit(event); }));
        this._register(this.instance);
    };
    SourceXYZComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-xyz',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceXYZComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceXYZComponent.ctorParameters = function () { return [
        { type: LayerTileComponent, decorators: [{ type: Optional }, { type: Host }] },
        { type: SourceRasterComponent, decorators: [{ type: Optional }, { type: Host }] }
    ]; };
    SourceXYZComponent.propDecorators = {
        cacheSize: [{ type: Input }],
        crossOrigin: [{ type: Input }],
        opaque: [{ type: Input }],
        projection: [{ type: Input }],
        reprojectionErrorThreshold: [{ type: Input }],
        minZoom: [{ type: Input }],
        maxZoom: [{ type: Input }],
        tileGrid: [{ type: Input }],
        tileLoadFunction: [{ type: Input }],
        tilePixelRatio: [{ type: Input }],
        tileSize: [{ type: Input }],
        tileUrlFunction: [{ type: Input }],
        url: [{ type: Input }],
        urls: [{ type: Input }],
        wrapX: [{ type: Input }],
        tileGridXYZ: [{ type: ContentChild, args: [TileGridComponent, { static: false },] }],
        tileLoadStart: [{ type: Output }],
        tileLoadEnd: [{ type: Output }],
        tileLoadError: [{ type: Output }]
    };
    return SourceXYZComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceXYZComponent.prototype.instance;
    /** @type {?} */
    SourceXYZComponent.prototype.cacheSize;
    /** @type {?} */
    SourceXYZComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceXYZComponent.prototype.opaque;
    /** @type {?} */
    SourceXYZComponent.prototype.projection;
    /** @type {?} */
    SourceXYZComponent.prototype.reprojectionErrorThreshold;
    /** @type {?} */
    SourceXYZComponent.prototype.minZoom;
    /** @type {?} */
    SourceXYZComponent.prototype.maxZoom;
    /** @type {?} */
    SourceXYZComponent.prototype.tileGrid;
    /** @type {?} */
    SourceXYZComponent.prototype.tileLoadFunction;
    /** @type {?} */
    SourceXYZComponent.prototype.tilePixelRatio;
    /** @type {?} */
    SourceXYZComponent.prototype.tileSize;
    /** @type {?} */
    SourceXYZComponent.prototype.tileUrlFunction;
    /** @type {?} */
    SourceXYZComponent.prototype.url;
    /** @type {?} */
    SourceXYZComponent.prototype.urls;
    /** @type {?} */
    SourceXYZComponent.prototype.wrapX;
    /** @type {?} */
    SourceXYZComponent.prototype.tileGridXYZ;
    /** @type {?} */
    SourceXYZComponent.prototype.tileLoadStart;
    /** @type {?} */
    SourceXYZComponent.prototype.tileLoadEnd;
    /** @type {?} */
    SourceXYZComponent.prototype.tileLoadError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceOsmComponent = /** @class */ (function (_super) {
    __extends(SourceOsmComponent, _super);
    function SourceOsmComponent(layer, raster) {
        var _this = _super.call(this, layer, raster) || this;
        _this.tileLoadStart = new EventEmitter();
        _this.tileLoadEnd = new EventEmitter();
        _this.tileLoadError = new EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    SourceOsmComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.tileGridXYZ) {
            this.tileGrid = this.tileGridXYZ.instance;
        }
        this.instance = new OSM(this);
        this.instance.on('tileloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.tileLoadStart.emit(event); }));
        this.instance.on('tileloadend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.tileLoadEnd.emit(event); }));
        this.instance.on('tileloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.tileLoadError.emit(event); }));
        this._register(this.instance);
    };
    SourceOsmComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-osm',
                    template: "\n    <div class=\"aol-source-osm\"></div>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceOsmComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceOsmComponent.ctorParameters = function () { return [
        { type: LayerTileComponent, decorators: [{ type: Host }, { type: Optional }] },
        { type: SourceRasterComponent, decorators: [{ type: Host }, { type: Optional }] }
    ]; };
    SourceOsmComponent.propDecorators = {
        attributions: [{ type: Input }],
        cacheSize: [{ type: Input }],
        crossOrigin: [{ type: Input }],
        maxZoom: [{ type: Input }],
        opaque: [{ type: Input }],
        reprojectionErrorThreshold: [{ type: Input }],
        tileLoadFunction: [{ type: Input }],
        url: [{ type: Input }],
        wrapX: [{ type: Input }],
        tileLoadStart: [{ type: Output }],
        tileLoadEnd: [{ type: Output }],
        tileLoadError: [{ type: Output }]
    };
    return SourceOsmComponent;
}(SourceXYZComponent));
if (false) {
    /** @type {?} */
    SourceOsmComponent.prototype.instance;
    /** @type {?} */
    SourceOsmComponent.prototype.attributions;
    /** @type {?} */
    SourceOsmComponent.prototype.cacheSize;
    /** @type {?} */
    SourceOsmComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceOsmComponent.prototype.maxZoom;
    /** @type {?} */
    SourceOsmComponent.prototype.opaque;
    /** @type {?} */
    SourceOsmComponent.prototype.reprojectionErrorThreshold;
    /** @type {?} */
    SourceOsmComponent.prototype.tileLoadFunction;
    /** @type {?} */
    SourceOsmComponent.prototype.url;
    /** @type {?} */
    SourceOsmComponent.prototype.wrapX;
    /** @type {?} */
    SourceOsmComponent.prototype.tileLoadStart;
    /** @type {?} */
    SourceOsmComponent.prototype.tileLoadEnd;
    /** @type {?} */
    SourceOsmComponent.prototype.tileLoadError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceBingmapsComponent = /** @class */ (function (_super) {
    __extends(SourceBingmapsComponent, _super);
    function SourceBingmapsComponent(layer) {
        var _this = _super.call(this, layer) || this;
        _this.imagerySet = 'Aerial';
        return _this;
    }
    /**
     * @return {?}
     */
    SourceBingmapsComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new BingMaps(this);
        this.host.instance.setSource(this.instance);
    };
    SourceBingmapsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-bingmaps',
                    template: "\n    <div class=\"aol-source-bingmaps\"></div>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceBingmapsComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceBingmapsComponent.ctorParameters = function () { return [
        { type: LayerTileComponent, decorators: [{ type: Host }] }
    ]; };
    SourceBingmapsComponent.propDecorators = {
        cacheSize: [{ type: Input }],
        hidpi: [{ type: Input }],
        culture: [{ type: Input }],
        key: [{ type: Input }],
        imagerySet: [{ type: Input }],
        maxZoom: [{ type: Input }],
        reprojectionErrorThreshold: [{ type: Input }],
        tileLoadFunction: [{ type: Input }],
        wrapX: [{ type: Input }]
    };
    return SourceBingmapsComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceBingmapsComponent.prototype.instance;
    /** @type {?} */
    SourceBingmapsComponent.prototype.cacheSize;
    /** @type {?} */
    SourceBingmapsComponent.prototype.hidpi;
    /** @type {?} */
    SourceBingmapsComponent.prototype.culture;
    /** @type {?} */
    SourceBingmapsComponent.prototype.key;
    /** @type {?} */
    SourceBingmapsComponent.prototype.imagerySet;
    /** @type {?} */
    SourceBingmapsComponent.prototype.maxZoom;
    /** @type {?} */
    SourceBingmapsComponent.prototype.reprojectionErrorThreshold;
    /** @type {?} */
    SourceBingmapsComponent.prototype.tileLoadFunction;
    /** @type {?} */
    SourceBingmapsComponent.prototype.wrapX;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceVectorComponent = /** @class */ (function (_super) {
    __extends(SourceVectorComponent, _super);
    function SourceVectorComponent(layer) {
        return _super.call(this, layer) || this;
    }
    /**
     * @return {?}
     */
    SourceVectorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new Vector$1(this);
        this.host.instance.setSource(this.instance);
    };
    SourceVectorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-vector',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceVectorComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceVectorComponent.ctorParameters = function () { return [
        { type: LayerVectorComponent, decorators: [{ type: Host }] }
    ]; };
    SourceVectorComponent.propDecorators = {
        overlaps: [{ type: Input }],
        useSpatialIndex: [{ type: Input }],
        wrapX: [{ type: Input }],
        url: [{ type: Input }],
        format: [{ type: Input }],
        strategy: [{ type: Input }]
    };
    return SourceVectorComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceVectorComponent.prototype.instance;
    /** @type {?} */
    SourceVectorComponent.prototype.overlaps;
    /** @type {?} */
    SourceVectorComponent.prototype.useSpatialIndex;
    /** @type {?} */
    SourceVectorComponent.prototype.wrapX;
    /** @type {?} */
    SourceVectorComponent.prototype.url;
    /** @type {?} */
    SourceVectorComponent.prototype.format;
    /** @type {?} */
    SourceVectorComponent.prototype.strategy;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceClusterComponent = /** @class */ (function (_super) {
    __extends(SourceClusterComponent, _super);
    function SourceClusterComponent(layer) {
        return _super.call(this, layer) || this;
    }
    /**
     * @return {?}
     */
    SourceClusterComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.source = this.sourceVectorComponent.instance;
        this.instance = new Cluster(this);
        this.host.instance.setSource(this.instance);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SourceClusterComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this.instance && changes.hasOwnProperty('distance')) {
            this.instance.setDistance(this.distance);
        }
    };
    SourceClusterComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-cluster',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceClusterComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceClusterComponent.ctorParameters = function () { return [
        { type: LayerVectorComponent, decorators: [{ type: Host }] }
    ]; };
    SourceClusterComponent.propDecorators = {
        distance: [{ type: Input }],
        geometryFunction: [{ type: Input }],
        wrapX: [{ type: Input }],
        sourceVectorComponent: [{ type: ContentChild, args: [SourceVectorComponent, { static: false },] }]
    };
    return SourceClusterComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceClusterComponent.prototype.instance;
    /** @type {?} */
    SourceClusterComponent.prototype.distance;
    /** @type {?} */
    SourceClusterComponent.prototype.geometryFunction;
    /** @type {?} */
    SourceClusterComponent.prototype.wrapX;
    /** @type {?} */
    SourceClusterComponent.prototype.sourceVectorComponent;
    /** @type {?} */
    SourceClusterComponent.prototype.source;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TileGridWMTSComponent = /** @class */ (function (_super) {
    __extends(TileGridWMTSComponent, _super);
    function TileGridWMTSComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    TileGridWMTSComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new WMTS(this);
    };
    TileGridWMTSComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-tilegrid-wmts',
                    template: ''
                }] }
    ];
    TileGridWMTSComponent.propDecorators = {
        origin: [{ type: Input }],
        origins: [{ type: Input }],
        resolutions: [{ type: Input }],
        matrixIds: [{ type: Input }],
        sizes: [{ type: Input }],
        tileSizes: [{ type: Input }],
        widths: [{ type: Input }]
    };
    return TileGridWMTSComponent;
}(TileGridComponent));
if (false) {
    /** @type {?} */
    TileGridWMTSComponent.prototype.instance;
    /** @type {?} */
    TileGridWMTSComponent.prototype.origin;
    /** @type {?} */
    TileGridWMTSComponent.prototype.origins;
    /** @type {?} */
    TileGridWMTSComponent.prototype.resolutions;
    /** @type {?} */
    TileGridWMTSComponent.prototype.matrixIds;
    /** @type {?} */
    TileGridWMTSComponent.prototype.sizes;
    /** @type {?} */
    TileGridWMTSComponent.prototype.tileSizes;
    /** @type {?} */
    TileGridWMTSComponent.prototype.widths;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceTileWMTSComponent = /** @class */ (function (_super) {
    __extends(SourceTileWMTSComponent, _super);
    function SourceTileWMTSComponent(layer) {
        var _this = _super.call(this, layer) || this;
        _this.tileLoadStart = new EventEmitter();
        _this.tileLoadEnd = new EventEmitter();
        _this.tileLoadError = new EventEmitter();
        return _this;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    SourceTileWMTSComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var properties = {};
        if (!this.instance) {
            return;
        }
        for (var key in changes) {
            if (changes.hasOwnProperty(key)) {
                switch (key) {
                    case 'url':
                        this.url = changes[key].currentValue;
                        this.setLayerSource();
                        break;
                    default:
                        break;
                }
                properties[key] = changes[key].currentValue;
            }
        }
        this.instance.setProperties(properties, false);
    };
    /**
     * @return {?}
     */
    SourceTileWMTSComponent.prototype.setLayerSource = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance = new WMTS$1(this);
        this.instance.on('tileloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.tileLoadStart.emit(event); }));
        this.instance.on('tileloadend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.tileLoadEnd.emit(event); }));
        this.instance.on('tileloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.tileLoadError.emit(event); }));
        this.host.instance.setSource(this.instance);
    };
    /**
     * @return {?}
     */
    SourceTileWMTSComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.tileGridWMTS) {
            this.tileGrid = this.tileGridWMTS.instance;
            this.setLayerSource();
        }
    };
    SourceTileWMTSComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-tilewmts',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceTileWMTSComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceTileWMTSComponent.ctorParameters = function () { return [
        { type: LayerTileComponent, decorators: [{ type: Host }] }
    ]; };
    SourceTileWMTSComponent.propDecorators = {
        cacheSize: [{ type: Input }],
        crossOrigin: [{ type: Input }],
        tileGrid: [{ type: Input }],
        projection: [{ type: Input }],
        reprojectionErrorThreshold: [{ type: Input }],
        requestEncoding: [{ type: Input }],
        layer: [{ type: Input }],
        style: [{ type: Input }],
        tileClass: [{ type: Input }],
        tilePixelRatio: [{ type: Input }],
        version: [{ type: Input }],
        format: [{ type: Input }],
        matrixSet: [{ type: Input }],
        dimensions: [{ type: Input }],
        url: [{ type: Input }],
        tileLoadFunction: [{ type: Input }],
        urls: [{ type: Input }],
        wrapX: [{ type: Input }],
        tileLoadStart: [{ type: Output }],
        tileLoadEnd: [{ type: Output }],
        tileLoadError: [{ type: Output }],
        tileGridWMTS: [{ type: ContentChild, args: [TileGridWMTSComponent, { static: false },] }]
    };
    return SourceTileWMTSComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceTileWMTSComponent.prototype.instance;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.cacheSize;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileGrid;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.projection;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.reprojectionErrorThreshold;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.requestEncoding;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.layer;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.style;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileClass;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tilePixelRatio;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.version;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.format;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.matrixSet;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.dimensions;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.url;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileLoadFunction;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.urls;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.wrapX;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileLoadStart;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileLoadEnd;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileLoadError;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileGridWMTS;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FormatComponent = /** @class */ (function () {
    function FormatComponent() {
        this.componentType = 'format';
    }
    return FormatComponent;
}());
if (false) {
    /** @type {?} */
    FormatComponent.prototype.instance;
    /** @type {?} */
    FormatComponent.prototype.componentType;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceVectorTileComponent = /** @class */ (function (_super) {
    __extends(SourceVectorTileComponent, _super);
    function SourceVectorTileComponent(layer) {
        return _super.call(this, layer) || this;
    }
    /* need the children to construct the OL3 object */
    /* need the children to construct the OL3 object */
    /**
     * @return {?}
     */
    SourceVectorTileComponent.prototype.ngAfterContentInit = /* need the children to construct the OL3 object */
    /**
     * @return {?}
     */
    function () {
        this.format = this.formatComponent.instance;
        this.tileGrid = this.tileGridComponent.instance;
        // console.log('creating ol.source.VectorTile instance with:', this);
        this.instance = new VectorTile$1(this);
        this.host.instance.setSource(this.instance);
    };
    SourceVectorTileComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-vectortile',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceVectorTileComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceVectorTileComponent.ctorParameters = function () { return [
        { type: LayerVectorTileComponent, decorators: [{ type: Host }] }
    ]; };
    SourceVectorTileComponent.propDecorators = {
        cacheSize: [{ type: Input }],
        overlaps: [{ type: Input }],
        projection: [{ type: Input }],
        tilePixelRatio: [{ type: Input }],
        tileUrlFunction: [{ type: Input }],
        url: [{ type: Input }],
        urls: [{ type: Input }],
        wrapX: [{ type: Input }],
        formatComponent: [{ type: ContentChild, args: [FormatComponent, { static: false },] }],
        tileGridComponent: [{ type: ContentChild, args: [TileGridComponent, { static: false },] }]
    };
    return SourceVectorTileComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceVectorTileComponent.prototype.instance;
    /** @type {?} */
    SourceVectorTileComponent.prototype.cacheSize;
    /** @type {?} */
    SourceVectorTileComponent.prototype.overlaps;
    /** @type {?} */
    SourceVectorTileComponent.prototype.projection;
    /** @type {?} */
    SourceVectorTileComponent.prototype.tilePixelRatio;
    /** @type {?} */
    SourceVectorTileComponent.prototype.tileUrlFunction;
    /** @type {?} */
    SourceVectorTileComponent.prototype.url;
    /** @type {?} */
    SourceVectorTileComponent.prototype.urls;
    /** @type {?} */
    SourceVectorTileComponent.prototype.wrapX;
    /** @type {?} */
    SourceVectorTileComponent.prototype.formatComponent;
    /** @type {?} */
    SourceVectorTileComponent.prototype.format;
    /** @type {?} */
    SourceVectorTileComponent.prototype.tileGridComponent;
    /** @type {?} */
    SourceVectorTileComponent.prototype.tileGrid;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceTileWMSComponent = /** @class */ (function (_super) {
    __extends(SourceTileWMSComponent, _super);
    function SourceTileWMSComponent(layer) {
        return _super.call(this, layer) || this;
    }
    /**
     * @return {?}
     */
    SourceTileWMSComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new TileWMS(this);
        this.host.instance.setSource(this.instance);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SourceTileWMSComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this.instance && changes.hasOwnProperty('params')) {
            this.instance.updateParams(this.params);
        }
    };
    SourceTileWMSComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-tilewms',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceTileWMSComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceTileWMSComponent.ctorParameters = function () { return [
        { type: LayerTileComponent, decorators: [{ type: Host }] }
    ]; };
    SourceTileWMSComponent.propDecorators = {
        cacheSize: [{ type: Input }],
        crossOrigin: [{ type: Input }],
        gutter: [{ type: Input }],
        hidpi: [{ type: Input }],
        params: [{ type: Input }],
        projection: [{ type: Input }],
        reprojectionErrorThreshold: [{ type: Input }],
        serverType: [{ type: Input }],
        tileGrid: [{ type: Input }],
        tileLoadFunction: [{ type: Input }],
        url: [{ type: Input }],
        urls: [{ type: Input }],
        wrapX: [{ type: Input }]
    };
    return SourceTileWMSComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceTileWMSComponent.prototype.instance;
    /** @type {?} */
    SourceTileWMSComponent.prototype.cacheSize;
    /** @type {?} */
    SourceTileWMSComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceTileWMSComponent.prototype.gutter;
    /** @type {?} */
    SourceTileWMSComponent.prototype.hidpi;
    /** @type {?} */
    SourceTileWMSComponent.prototype.params;
    /** @type {?} */
    SourceTileWMSComponent.prototype.projection;
    /** @type {?} */
    SourceTileWMSComponent.prototype.reprojectionErrorThreshold;
    /** @type {?} */
    SourceTileWMSComponent.prototype.serverType;
    /** @type {?} */
    SourceTileWMSComponent.prototype.tileGrid;
    /** @type {?} */
    SourceTileWMSComponent.prototype.tileLoadFunction;
    /** @type {?} */
    SourceTileWMSComponent.prototype.url;
    /** @type {?} */
    SourceTileWMSComponent.prototype.urls;
    /** @type {?} */
    SourceTileWMSComponent.prototype.wrapX;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceTileJSONComponent = /** @class */ (function (_super) {
    __extends(SourceTileJSONComponent, _super);
    function SourceTileJSONComponent(layer) {
        return _super.call(this, layer) || this;
    }
    /**
     * @return {?}
     */
    SourceTileJSONComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new TileJSON(this);
        this.host.instance.setSource(this.instance);
    };
    SourceTileJSONComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-tilejson',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceTileJSONComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceTileJSONComponent.ctorParameters = function () { return [
        { type: LayerTileComponent, decorators: [{ type: Host }] }
    ]; };
    SourceTileJSONComponent.propDecorators = {
        url: [{ type: Input }]
    };
    return SourceTileJSONComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceTileJSONComponent.prototype.instance;
    /** @type {?} */
    SourceTileJSONComponent.prototype.url;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceGeoJSONComponent = /** @class */ (function (_super) {
    __extends(SourceGeoJSONComponent, _super);
    function SourceGeoJSONComponent(layer) {
        return _super.call(this, layer) || this;
    }
    /**
     * @return {?}
     */
    SourceGeoJSONComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.format = new GeoJSON(this);
        this.instance = new Vector$1(this);
        this.host.instance.setSource(this.instance);
    };
    SourceGeoJSONComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-geojson',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceGeoJSONComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceGeoJSONComponent.ctorParameters = function () { return [
        { type: LayerVectorComponent, decorators: [{ type: Host }] }
    ]; };
    SourceGeoJSONComponent.propDecorators = {
        defaultDataProjection: [{ type: Input }],
        featureProjection: [{ type: Input }],
        geometryName: [{ type: Input }],
        url: [{ type: Input }]
    };
    return SourceGeoJSONComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceGeoJSONComponent.prototype.instance;
    /** @type {?} */
    SourceGeoJSONComponent.prototype.format;
    /** @type {?} */
    SourceGeoJSONComponent.prototype.defaultDataProjection;
    /** @type {?} */
    SourceGeoJSONComponent.prototype.featureProjection;
    /** @type {?} */
    SourceGeoJSONComponent.prototype.geometryName;
    /** @type {?} */
    SourceGeoJSONComponent.prototype.url;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceImageStaticComponent = /** @class */ (function (_super) {
    __extends(SourceImageStaticComponent, _super);
    function SourceImageStaticComponent(layer) {
        var _this = _super.call(this, layer) || this;
        _this.imageLoadStart = new EventEmitter();
        _this.imageLoadEnd = new EventEmitter();
        _this.imageLoadError = new EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    SourceImageStaticComponent.prototype.setLayerSource = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance = new ImageStatic(this);
        this.host.instance.setSource(this.instance);
        this.instance.on('imageloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.imageLoadStart.emit(event); }));
        this.instance.on('imageloadend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.imageLoadEnd.emit(event); }));
        this.instance.on('imageloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.imageLoadError.emit(event); }));
    };
    /**
     * @return {?}
     */
    SourceImageStaticComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.setLayerSource();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SourceImageStaticComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var properties = {};
        if (!this.instance) {
            return;
        }
        for (var key in changes) {
            if (changes.hasOwnProperty(key)) {
                switch (key) {
                    case 'url':
                        this.url = changes[key].currentValue;
                        this.setLayerSource();
                        break;
                    default:
                        break;
                }
                properties[key] = changes[key].currentValue;
            }
        }
        this.instance.setProperties(properties, false);
    };
    SourceImageStaticComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-imagestatic',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceImageStaticComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceImageStaticComponent.ctorParameters = function () { return [
        { type: LayerImageComponent, decorators: [{ type: Host }] }
    ]; };
    SourceImageStaticComponent.propDecorators = {
        projection: [{ type: Input }],
        imageExtent: [{ type: Input }],
        url: [{ type: Input }],
        attributions: [{ type: Input }],
        crossOrigin: [{ type: Input }],
        imageLoadFunction: [{ type: Input }],
        imageSize: [{ type: Input }],
        imageLoadStart: [{ type: Output }],
        imageLoadEnd: [{ type: Output }],
        imageLoadError: [{ type: Output }]
    };
    return SourceImageStaticComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceImageStaticComponent.prototype.instance;
    /** @type {?} */
    SourceImageStaticComponent.prototype.projection;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageExtent;
    /** @type {?} */
    SourceImageStaticComponent.prototype.url;
    /** @type {?} */
    SourceImageStaticComponent.prototype.attributions;
    /** @type {?} */
    SourceImageStaticComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageLoadFunction;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageSize;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageLoadStart;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageLoadEnd;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageLoadError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceImageWMSComponent = /** @class */ (function (_super) {
    __extends(SourceImageWMSComponent, _super);
    function SourceImageWMSComponent(layer) {
        var _this = _super.call(this, layer) || this;
        _this.imageLoadStart = new EventEmitter();
        _this.imageLoadEnd = new EventEmitter();
        _this.imageLoadError = new EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    SourceImageWMSComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance = new ImageWMS(this);
        this.host.instance.setSource(this.instance);
        this.instance.on('imageloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.imageLoadStart.emit(event); }));
        this.instance.on('imageloadend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.imageLoadEnd.emit(event); }));
        this.instance.on('imageloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.imageLoadError.emit(event); }));
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SourceImageWMSComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this.instance && changes.hasOwnProperty('params')) {
            this.instance.updateParams(this.params);
        }
    };
    SourceImageWMSComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-imagewms',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceImageWMSComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceImageWMSComponent.ctorParameters = function () { return [
        { type: LayerImageComponent, decorators: [{ type: Host }] }
    ]; };
    SourceImageWMSComponent.propDecorators = {
        attributions: [{ type: Input }],
        crossOrigin: [{ type: Input }],
        hidpi: [{ type: Input }],
        serverType: [{ type: Input }],
        imageLoadFunction: [{ type: Input }],
        params: [{ type: Input }],
        projection: [{ type: Input }],
        ratio: [{ type: Input }],
        resolutions: [{ type: Input }],
        url: [{ type: Input }],
        imageLoadStart: [{ type: Output }],
        imageLoadEnd: [{ type: Output }],
        imageLoadError: [{ type: Output }]
    };
    return SourceImageWMSComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceImageWMSComponent.prototype.instance;
    /** @type {?} */
    SourceImageWMSComponent.prototype.attributions;
    /** @type {?} */
    SourceImageWMSComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceImageWMSComponent.prototype.hidpi;
    /** @type {?} */
    SourceImageWMSComponent.prototype.serverType;
    /** @type {?} */
    SourceImageWMSComponent.prototype.imageLoadFunction;
    /** @type {?} */
    SourceImageWMSComponent.prototype.params;
    /** @type {?} */
    SourceImageWMSComponent.prototype.projection;
    /** @type {?} */
    SourceImageWMSComponent.prototype.ratio;
    /** @type {?} */
    SourceImageWMSComponent.prototype.resolutions;
    /** @type {?} */
    SourceImageWMSComponent.prototype.url;
    /** @type {?} */
    SourceImageWMSComponent.prototype.imageLoadStart;
    /** @type {?} */
    SourceImageWMSComponent.prototype.imageLoadEnd;
    /** @type {?} */
    SourceImageWMSComponent.prototype.imageLoadError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceImageArcGISRestComponent = /** @class */ (function (_super) {
    __extends(SourceImageArcGISRestComponent, _super);
    function SourceImageArcGISRestComponent(layer) {
        var _this = _super.call(this, layer) || this;
        _this.ratio = 1.5;
        _this.imageLoadStart = new EventEmitter();
        _this.imageLoadEnd = new EventEmitter();
        _this.imageLoadError = new EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    SourceImageArcGISRestComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance = new ImageArcGISRest(this);
        this.host.instance.setSource(this.instance);
        this.instance.on('imageloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.imageLoadStart.emit(event); }));
        this.instance.on('imageloadend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.imageLoadEnd.emit(event); }));
        this.instance.on('imageloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.imageLoadError.emit(event); }));
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SourceImageArcGISRestComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this.instance && changes.hasOwnProperty('params')) {
            this.instance.updateParams(this.params);
        }
    };
    SourceImageArcGISRestComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-imagearcgisrest',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceImageArcGISRestComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceImageArcGISRestComponent.ctorParameters = function () { return [
        { type: LayerImageComponent, decorators: [{ type: Host }] }
    ]; };
    SourceImageArcGISRestComponent.propDecorators = {
        projection: [{ type: Input }],
        url: [{ type: Input }],
        attributions: [{ type: Input }],
        crossOrigin: [{ type: Input }],
        imageLoadFunction: [{ type: Input }],
        params: [{ type: Input }],
        ratio: [{ type: Input }],
        resolutions: [{ type: Input }],
        wrapX: [{ type: Input }],
        imageLoadStart: [{ type: Output }],
        imageLoadEnd: [{ type: Output }],
        imageLoadError: [{ type: Output }]
    };
    return SourceImageArcGISRestComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.instance;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.projection;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.url;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.attributions;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.imageLoadFunction;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.params;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.ratio;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.resolutions;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.wrapX;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.imageLoadStart;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.imageLoadEnd;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.imageLoadError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FeatureComponent = /** @class */ (function () {
    function FeatureComponent(host) {
        this.host = host;
        this.componentType = 'feature';
    }
    /**
     * @return {?}
     */
    FeatureComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new Feature();
        if (this.id !== undefined) {
            this.instance.setId(this.id);
        }
        this.host.instance.addFeature(this.instance);
    };
    /**
     * @return {?}
     */
    FeatureComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.host.instance.removeFeature(this.instance);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    FeatureComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this.instance) {
            this.instance.setId(this.id);
        }
    };
    FeatureComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-feature',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    FeatureComponent.ctorParameters = function () { return [
        { type: SourceVectorComponent }
    ]; };
    FeatureComponent.propDecorators = {
        id: [{ type: Input }]
    };
    return FeatureComponent;
}());
if (false) {
    /** @type {?} */
    FeatureComponent.prototype.componentType;
    /** @type {?} */
    FeatureComponent.prototype.instance;
    /** @type {?} */
    FeatureComponent.prototype.id;
    /**
     * @type {?}
     * @private
     */
    FeatureComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var SimpleGeometryComponent = /** @class */ (function () {
    function SimpleGeometryComponent(map, host) {
        this.map = map;
        this.host = host;
        this.componentType = 'simple-geometry';
    }
    /**
     * @return {?}
     */
    SimpleGeometryComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.host.instance.setGeometry(this.instance);
    };
    SimpleGeometryComponent.propDecorators = {
        srid: [{ type: Input }]
    };
    return SimpleGeometryComponent;
}());
if (false) {
    /** @type {?} */
    SimpleGeometryComponent.prototype.instance;
    /** @type {?} */
    SimpleGeometryComponent.prototype.componentType;
    /** @type {?} */
    SimpleGeometryComponent.prototype.srid;
    /**
     * @type {?}
     * @protected
     */
    SimpleGeometryComponent.prototype.map;
    /**
     * @type {?}
     * @protected
     */
    SimpleGeometryComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GeometryCircleComponent = /** @class */ (function (_super) {
    __extends(GeometryCircleComponent, _super);
    function GeometryCircleComponent(map, host) {
        var _this = _super.call(this, map, host) || this;
        _this.componentType = 'geometry-circle';
        // defaulting coordinates to [0,0]. To be overridden in child component.
        _this.instance = new Circle([0, 0]);
        return _this;
    }
    Object.defineProperty(GeometryCircleComponent.prototype, "radius", {
        get: /**
         * @return {?}
         */
        function () {
            return this.instance.getRadius();
        },
        set: /**
         * @param {?} radius
         * @return {?}
         */
        function (radius) {
            this.instance.setRadius(radius);
        },
        enumerable: true,
        configurable: true
    });
    GeometryCircleComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-geometry-circle',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    GeometryCircleComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: FeatureComponent }
    ]; };
    GeometryCircleComponent.propDecorators = {
        radius: [{ type: Input }]
    };
    return GeometryCircleComponent;
}(SimpleGeometryComponent));
if (false) {
    /** @type {?} */
    GeometryCircleComponent.prototype.componentType;
    /** @type {?} */
    GeometryCircleComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GeometryLinestringComponent = /** @class */ (function (_super) {
    __extends(GeometryLinestringComponent, _super);
    function GeometryLinestringComponent(map, host) {
        var _this = _super.call(this, map, host) || this;
        _this.componentType = 'geometry-linestring';
        return _this;
    }
    /**
     * @return {?}
     */
    GeometryLinestringComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new LineString([[0, 0], [1, 1]]);
        _super.prototype.ngOnInit.call(this);
    };
    GeometryLinestringComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-geometry-linestring',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    GeometryLinestringComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: FeatureComponent }
    ]; };
    return GeometryLinestringComponent;
}(SimpleGeometryComponent));
if (false) {
    /** @type {?} */
    GeometryLinestringComponent.prototype.componentType;
    /** @type {?} */
    GeometryLinestringComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GeometryMultiLinestringComponent = /** @class */ (function (_super) {
    __extends(GeometryMultiLinestringComponent, _super);
    function GeometryMultiLinestringComponent(map, host) {
        var _this = _super.call(this, map, host) || this;
        _this.componentType = 'geometry-multilinestring';
        return _this;
    }
    /**
     * @return {?}
     */
    GeometryMultiLinestringComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new MultiLineString([[[0, 0], [1, 1]]]);
        _super.prototype.ngOnInit.call(this);
    };
    GeometryMultiLinestringComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-geometry-multilinestring',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    GeometryMultiLinestringComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: FeatureComponent }
    ]; };
    return GeometryMultiLinestringComponent;
}(SimpleGeometryComponent));
if (false) {
    /** @type {?} */
    GeometryMultiLinestringComponent.prototype.componentType;
    /** @type {?} */
    GeometryMultiLinestringComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GeometryMultiPointComponent = /** @class */ (function (_super) {
    __extends(GeometryMultiPointComponent, _super);
    function GeometryMultiPointComponent(map, host) {
        var _this = _super.call(this, map, host) || this;
        _this.componentType = 'geometry-multipoint';
        return _this;
    }
    /**
     * @return {?}
     */
    GeometryMultiPointComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new MultiPoint([[0, 0], [1, 1]]);
        _super.prototype.ngOnInit.call(this);
    };
    GeometryMultiPointComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-geometry-multipoint',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    GeometryMultiPointComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: FeatureComponent }
    ]; };
    return GeometryMultiPointComponent;
}(SimpleGeometryComponent));
if (false) {
    /** @type {?} */
    GeometryMultiPointComponent.prototype.componentType;
    /** @type {?} */
    GeometryMultiPointComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GeometryMultiPolygonComponent = /** @class */ (function (_super) {
    __extends(GeometryMultiPolygonComponent, _super);
    function GeometryMultiPolygonComponent(map, host) {
        var _this = _super.call(this, map, host) || this;
        _this.componentType = 'geometry-multipolygon';
        return _this;
    }
    /**
     * @return {?}
     */
    GeometryMultiPolygonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new MultiPolygon([[[[0, 0], [1, 1], [0, 1]]]]);
        _super.prototype.ngOnInit.call(this);
    };
    GeometryMultiPolygonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-geometry-multipolygon',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    GeometryMultiPolygonComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: FeatureComponent }
    ]; };
    return GeometryMultiPolygonComponent;
}(SimpleGeometryComponent));
if (false) {
    /** @type {?} */
    GeometryMultiPolygonComponent.prototype.componentType;
    /** @type {?} */
    GeometryMultiPolygonComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GeometryPointComponent = /** @class */ (function (_super) {
    __extends(GeometryPointComponent, _super);
    function GeometryPointComponent(map, host) {
        var _this = _super.call(this, map, host) || this;
        _this.componentType = 'geometry-point';
        return _this;
    }
    /**
     * @return {?}
     */
    GeometryPointComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new Point([0, 0]);
        _super.prototype.ngOnInit.call(this);
    };
    GeometryPointComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-geometry-point',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    GeometryPointComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: FeatureComponent }
    ]; };
    return GeometryPointComponent;
}(SimpleGeometryComponent));
if (false) {
    /** @type {?} */
    GeometryPointComponent.prototype.componentType;
    /** @type {?} */
    GeometryPointComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GeometryPolygonComponent = /** @class */ (function (_super) {
    __extends(GeometryPolygonComponent, _super);
    function GeometryPolygonComponent(map, host) {
        var _this = _super.call(this, map, host) || this;
        _this.componentType = 'geometry-polygon';
        return _this;
    }
    /**
     * @return {?}
     */
    GeometryPolygonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new Polygon([[[0, 0], [1, 1], [0, 1]]]);
        _super.prototype.ngOnInit.call(this);
    };
    GeometryPolygonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-geometry-polygon',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    GeometryPolygonComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: FeatureComponent }
    ]; };
    return GeometryPolygonComponent;
}(SimpleGeometryComponent));
if (false) {
    /** @type {?} */
    GeometryPolygonComponent.prototype.componentType;
    /** @type {?} */
    GeometryPolygonComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentComponent = /** @class */ (function () {
    function ContentComponent(elementRef) {
        this.elementRef = elementRef;
    }
    ContentComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-content',
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    ContentComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return ContentComponent;
}());
if (false) {
    /** @type {?} */
    ContentComponent.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OverlayComponent = /** @class */ (function () {
    function OverlayComponent(map) {
        this.map = map;
        this.componentType = 'overlay';
    }
    /**
     * @return {?}
     */
    OverlayComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.content) {
            this.element = this.content.elementRef.nativeElement;
            this.instance = new Overlay(this);
            this.map.instance.addOverlay(this.instance);
        }
    };
    /**
     * @return {?}
     */
    OverlayComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.instance) {
            this.map.instance.removeOverlay(this.instance);
        }
    };
    OverlayComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-overlay',
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    OverlayComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    OverlayComponent.propDecorators = {
        content: [{ type: ContentChild, args: [ContentComponent, { static: true },] }],
        id: [{ type: Input }],
        offset: [{ type: Input }],
        positioning: [{ type: Input }],
        stopEvent: [{ type: Input }],
        insertFirst: [{ type: Input }],
        autoPan: [{ type: Input }],
        autoPanAnimation: [{ type: Input }],
        autoPanMargin: [{ type: Input }]
    };
    return OverlayComponent;
}());
if (false) {
    /** @type {?} */
    OverlayComponent.prototype.componentType;
    /** @type {?} */
    OverlayComponent.prototype.instance;
    /** @type {?} */
    OverlayComponent.prototype.element;
    /** @type {?} */
    OverlayComponent.prototype.content;
    /** @type {?} */
    OverlayComponent.prototype.id;
    /** @type {?} */
    OverlayComponent.prototype.offset;
    /** @type {?} */
    OverlayComponent.prototype.positioning;
    /** @type {?} */
    OverlayComponent.prototype.stopEvent;
    /** @type {?} */
    OverlayComponent.prototype.insertFirst;
    /** @type {?} */
    OverlayComponent.prototype.autoPan;
    /** @type {?} */
    OverlayComponent.prototype.autoPanAnimation;
    /** @type {?} */
    OverlayComponent.prototype.autoPanMargin;
    /**
     * @type {?}
     * @private
     */
    OverlayComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CoordinateComponent = /** @class */ (function () {
    function CoordinateComponent(map, viewHost, geometryPointHost, geometryCircleHost, overlayHost) {
        this.map = map;
        this.mapSrid = 'EPSG:3857';
        this.srid = 'EPSG:3857';
        // console.log('instancing aol-coordinate');
        if (geometryPointHost !== null) {
            this.host = geometryPointHost;
        }
        else if (geometryCircleHost !== null) {
            this.host = geometryCircleHost;
        }
        else if (viewHost !== null) {
            this.host = viewHost;
        }
        else if (overlayHost !== null) {
            this.host = overlayHost;
        }
    }
    /**
     * @return {?}
     */
    CoordinateComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.map.instance.on('change:view', (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.onMapViewChanged(e); }));
        this.mapSrid = this.map.instance
            .getView()
            .getProjection()
            .getCode();
        this.transformCoordinates();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    CoordinateComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.transformCoordinates();
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    CoordinateComponent.prototype.onMapViewChanged = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.mapSrid = event.target
            .get(event.key)
            .getProjection()
            .getCode();
        this.transformCoordinates();
    };
    /**
     * @private
     * @return {?}
     */
    CoordinateComponent.prototype.transformCoordinates = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var transformedCoordinates;
        if (this.srid === this.mapSrid) {
            transformedCoordinates = [this.x, this.y];
        }
        else {
            transformedCoordinates = transform([this.x, this.y], this.srid, this.mapSrid);
        }
        switch (this.host.componentType) {
            case 'geometry-point':
                this.host.instance.setCoordinates(transformedCoordinates);
                break;
            case 'geometry-circle':
            case 'view':
                this.host.instance.setCenter(transformedCoordinates);
                break;
            case 'overlay':
                this.host.instance.setPosition(transformedCoordinates);
                break;
        }
    };
    CoordinateComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-coordinate',
                    template: "\n    <div class=\"aol-coordinate\"></div>\n  "
                }] }
    ];
    /** @nocollapse */
    CoordinateComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: ViewComponent, decorators: [{ type: Optional }] },
        { type: GeometryPointComponent, decorators: [{ type: Optional }] },
        { type: GeometryCircleComponent, decorators: [{ type: Optional }] },
        { type: OverlayComponent, decorators: [{ type: Optional }] }
    ]; };
    CoordinateComponent.propDecorators = {
        x: [{ type: Input }],
        y: [{ type: Input }],
        srid: [{ type: Input }]
    };
    return CoordinateComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    CoordinateComponent.prototype.host;
    /**
     * @type {?}
     * @private
     */
    CoordinateComponent.prototype.mapSrid;
    /** @type {?} */
    CoordinateComponent.prototype.x;
    /** @type {?} */
    CoordinateComponent.prototype.y;
    /** @type {?} */
    CoordinateComponent.prototype.srid;
    /**
     * @type {?}
     * @private
     */
    CoordinateComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CollectionCoordinatesComponent = /** @class */ (function () {
    function CollectionCoordinatesComponent(map, geometryLinestring, geometryPolygon, geometryMultipoint, geometryMultilinestring, geometryMultipolygon) {
        this.map = map;
        this.mapSrid = 'EPSG:3857';
        this.srid = 'EPSG:3857';
        if (!!geometryLinestring) {
            this.host = geometryLinestring;
        }
        else if (!!geometryPolygon) {
            this.host = geometryPolygon;
        }
        else if (!!geometryMultipoint) {
            this.host = geometryMultipoint;
        }
        else if (!!geometryMultilinestring) {
            this.host = geometryMultilinestring;
        }
        else if (!!geometryMultipolygon) {
            this.host = geometryMultipolygon;
        }
        else {
            throw new Error('aol-collection-coordinates must be a child of a geometry component');
        }
    }
    /**
     * @return {?}
     */
    CollectionCoordinatesComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.map.instance.on('change:view', (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.onMapViewChanged(e); }));
        this.mapSrid = this.map.instance
            .getView()
            .getProjection()
            .getCode();
        this.transformCoordinates();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    CollectionCoordinatesComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.transformCoordinates();
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    CollectionCoordinatesComponent.prototype.onMapViewChanged = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.mapSrid = event.target
            .get(event.key)
            .getProjection()
            .getCode();
        this.transformCoordinates();
    };
    /**
     * @private
     * @return {?}
     */
    CollectionCoordinatesComponent.prototype.transformCoordinates = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var transformedCoordinates;
        if (this.srid === this.mapSrid) {
            transformedCoordinates = this.coordinates;
        }
        else {
            switch (this.host.componentType) {
                case 'geometry-linestring':
                case 'geometry-multipoint':
                    transformedCoordinates = ((/** @type {?} */ (this.coordinates))).map((/**
                     * @param {?} c
                     * @return {?}
                     */
                    function (c) { return transform(c, _this.srid, _this.mapSrid); }));
                    break;
                case 'geometry-polygon':
                case 'geometry-multilinestring':
                    transformedCoordinates = ((/** @type {?} */ (this.coordinates))).map((/**
                     * @param {?} cc
                     * @return {?}
                     */
                    function (cc) {
                        return cc.map((/**
                         * @param {?} c
                         * @return {?}
                         */
                        function (c) { return transform(c, _this.srid, _this.mapSrid); }));
                    }));
                    break;
                case 'geometry-multipolygon':
                    transformedCoordinates = ((/** @type {?} */ (this.coordinates))).map((/**
                     * @param {?} ccc
                     * @return {?}
                     */
                    function (ccc) {
                        return ccc.map((/**
                         * @param {?} cc
                         * @return {?}
                         */
                        function (cc) { return cc.map((/**
                         * @param {?} c
                         * @return {?}
                         */
                        function (c) { return transform(c, _this.srid, _this.mapSrid); })); }));
                    }));
                    break;
            }
        }
        this.host.instance.setCoordinates(transformedCoordinates);
    };
    CollectionCoordinatesComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-collection-coordinates',
                    template: "\n    <div class=\"aol-collection-coordinates\"></div>\n  "
                }] }
    ];
    /** @nocollapse */
    CollectionCoordinatesComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: GeometryLinestringComponent, decorators: [{ type: Optional }] },
        { type: GeometryPolygonComponent, decorators: [{ type: Optional }] },
        { type: GeometryMultiPointComponent, decorators: [{ type: Optional }] },
        { type: GeometryMultiLinestringComponent, decorators: [{ type: Optional }] },
        { type: GeometryMultiPolygonComponent, decorators: [{ type: Optional }] }
    ]; };
    CollectionCoordinatesComponent.propDecorators = {
        coordinates: [{ type: Input }],
        srid: [{ type: Input }]
    };
    return CollectionCoordinatesComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    CollectionCoordinatesComponent.prototype.host;
    /**
     * @type {?}
     * @private
     */
    CollectionCoordinatesComponent.prototype.mapSrid;
    /** @type {?} */
    CollectionCoordinatesComponent.prototype.coordinates;
    /** @type {?} */
    CollectionCoordinatesComponent.prototype.srid;
    /**
     * @type {?}
     * @private
     */
    CollectionCoordinatesComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StyleComponent = /** @class */ (function () {
    function StyleComponent(featureHost, layerHost) {
        this.componentType = 'style';
        // console.log('creating aol-style');
        this.host = !!featureHost ? featureHost : layerHost;
        if (!this.host) {
            throw new Error('aol-style must be applied to a feature or a layer');
        }
    }
    /**
     * @return {?}
     */
    StyleComponent.prototype.update = /**
     * @return {?}
     */
    function () {
        // console.log('updating style\'s host: ', this.host);
        this.host.instance.changed();
    };
    /**
     * @return {?}
     */
    StyleComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // console.log('creating aol-style instance with: ', this);
        this.instance = new Style(this);
        this.host.instance.setStyle(this.instance);
    };
    StyleComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-style',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    StyleComponent.ctorParameters = function () { return [
        { type: FeatureComponent, decorators: [{ type: Optional }] },
        { type: LayerVectorComponent, decorators: [{ type: Optional }] }
    ]; };
    StyleComponent.propDecorators = {
        geometry: [{ type: Input }],
        fill: [{ type: Input }],
        image: [{ type: Input }],
        stroke: [{ type: Input }],
        text: [{ type: Input }],
        zIndex: [{ type: Input }]
    };
    return StyleComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    StyleComponent.prototype.host;
    /** @type {?} */
    StyleComponent.prototype.instance;
    /** @type {?} */
    StyleComponent.prototype.componentType;
    /** @type {?} */
    StyleComponent.prototype.geometry;
    /** @type {?} */
    StyleComponent.prototype.fill;
    /** @type {?} */
    StyleComponent.prototype.image;
    /** @type {?} */
    StyleComponent.prototype.stroke;
    /** @type {?} */
    StyleComponent.prototype.text;
    /** @type {?} */
    StyleComponent.prototype.zIndex;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StyleCircleComponent = /** @class */ (function () {
    function StyleCircleComponent(host) {
        this.host = host;
        this.componentType = 'style-circle';
    }
    /**
     * WORK-AROUND: since the re-rendering is not triggered on style change
     * we trigger a radius change.
     * see openlayers #6233 and #5775
     */
    /**
     * WORK-AROUND: since the re-rendering is not triggered on style change
     * we trigger a radius change.
     * see openlayers #6233 and #5775
     * @return {?}
     */
    StyleCircleComponent.prototype.update = /**
     * WORK-AROUND: since the re-rendering is not triggered on style change
     * we trigger a radius change.
     * see openlayers #6233 and #5775
     * @return {?}
     */
    function () {
        if (!!this.instance) {
            // console.log('setting ol.style.Circle instance\'s radius');
            this.instance.setRadius(this.radius);
        }
        this.host.update();
    };
    /**
     * @return {?}
     */
    StyleCircleComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        // console.log('creating ol.style.Circle instance with: ', this);
        this.instance = new Circle$1(this);
        this.host.instance.setImage(this.instance);
        this.host.update();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    StyleCircleComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.instance) {
            return;
        }
        if (changes.radius) {
            this.instance.setRadius(changes.radius.currentValue);
        }
        // console.log('changes detected in aol-style-circle, setting new radius: ', changes['radius'].currentValue);
    };
    /**
     * @return {?}
     */
    StyleCircleComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // console.log('removing aol-style-circle');
        this.host.instance.setImage(null);
    };
    StyleCircleComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-style-circle',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    StyleCircleComponent.ctorParameters = function () { return [
        { type: StyleComponent, decorators: [{ type: Host }] }
    ]; };
    StyleCircleComponent.propDecorators = {
        fill: [{ type: Input }],
        radius: [{ type: Input }],
        snapToPixel: [{ type: Input }],
        stroke: [{ type: Input }],
        atlasManager: [{ type: Input }]
    };
    return StyleCircleComponent;
}());
if (false) {
    /** @type {?} */
    StyleCircleComponent.prototype.componentType;
    /** @type {?} */
    StyleCircleComponent.prototype.instance;
    /** @type {?} */
    StyleCircleComponent.prototype.fill;
    /** @type {?} */
    StyleCircleComponent.prototype.radius;
    /** @type {?} */
    StyleCircleComponent.prototype.snapToPixel;
    /** @type {?} */
    StyleCircleComponent.prototype.stroke;
    /** @type {?} */
    StyleCircleComponent.prototype.atlasManager;
    /**
     * @type {?}
     * @private
     */
    StyleCircleComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StyleTextComponent = /** @class */ (function () {
    function StyleTextComponent(host) {
        this.host = host;
        this.componentType = 'style-text';
        if (!host) {
            throw new Error('aol-style-text must be a descendant of aol-style');
        }
        // console.log('creating aol-style-text with: ', this);
    }
    /**
     * @return {?}
     */
    StyleTextComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // console.log('creating ol.style.Text instance with: ', this);
        this.instance = new Text(this);
        this.host.instance.setText(this.instance);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    StyleTextComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.instance) {
            return;
        }
        if (changes.font) {
            this.instance.setFont(changes.font.currentValue);
        }
        if (changes.offsetX) {
            this.instance.setOffsetX(changes.offsetX.currentValue);
        }
        if (changes.offsetY) {
            this.instance.setOffsetY(changes.offsetY.currentValue);
        }
        if (changes.scale) {
            this.instance.setScale(changes.scale.currentValue);
        }
        if (changes.rotation) {
            this.instance.setRotation(changes.rotation.currentValue);
        }
        if (changes.text) {
            this.instance.setText(changes.text.currentValue);
        }
        if (changes.textAlign) {
            this.instance.setTextAlign(changes.textAlign.currentValue);
        }
        if (changes.textBaseLine) {
            this.instance.setTextBaseline(changes.textBaseLine.currentValue);
        }
        this.host.update();
        // console.log('changes detected in aol-style-text, setting new properties: ', changes);
    };
    StyleTextComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-style-text',
                    template: "\n    <div class=\"aol-style-text\"></div>\n  "
                }] }
    ];
    /** @nocollapse */
    StyleTextComponent.ctorParameters = function () { return [
        { type: StyleComponent, decorators: [{ type: Optional }] }
    ]; };
    StyleTextComponent.propDecorators = {
        font: [{ type: Input }],
        offsetX: [{ type: Input }],
        offsetY: [{ type: Input }],
        scale: [{ type: Input }],
        rotateWithView: [{ type: Input }],
        rotation: [{ type: Input }],
        text: [{ type: Input }],
        textAlign: [{ type: Input }],
        textBaseLine: [{ type: Input }]
    };
    return StyleTextComponent;
}());
if (false) {
    /** @type {?} */
    StyleTextComponent.prototype.instance;
    /** @type {?} */
    StyleTextComponent.prototype.componentType;
    /** @type {?} */
    StyleTextComponent.prototype.font;
    /** @type {?} */
    StyleTextComponent.prototype.offsetX;
    /** @type {?} */
    StyleTextComponent.prototype.offsetY;
    /** @type {?} */
    StyleTextComponent.prototype.scale;
    /** @type {?} */
    StyleTextComponent.prototype.rotateWithView;
    /** @type {?} */
    StyleTextComponent.prototype.rotation;
    /** @type {?} */
    StyleTextComponent.prototype.text;
    /** @type {?} */
    StyleTextComponent.prototype.textAlign;
    /** @type {?} */
    StyleTextComponent.prototype.textBaseLine;
    /**
     * @type {?}
     * @private
     */
    StyleTextComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StyleStrokeComponent = /** @class */ (function () {
    function StyleStrokeComponent(styleHost, styleCircleHost, styleTextHost) {
        if (!styleHost) {
            throw new Error('aol-style-stroke must be a descendant of aol-style');
        }
        if (!!styleTextHost) {
            this.host = styleTextHost;
        }
        else if (!!styleCircleHost) {
            this.host = styleCircleHost;
        }
        else {
            this.host = styleHost;
        }
        // console.log('creating aol-style-stroke with: ', this);
    }
    /**
     * @return {?}
     */
    StyleStrokeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // console.log('creating ol.style.Stroke instance with: ', this);
        this.instance = new Stroke(this);
        switch (this.host.componentType) {
            case 'style':
                this.host.instance.setStroke(this.instance);
                // console.log('setting ol.style instance\'s stroke:', this.host);
                break;
            case 'style-text':
                this.host.instance.setStroke(this.instance);
                break;
            case 'style-circle':
                this.host.stroke = this.instance;
                // console.log('setting ol.style.circle instance\'s stroke:', this.host);
                break;
            default:
                throw new Error('unknown host type: ' + this.host);
            // break;
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    StyleStrokeComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.instance) {
            return;
        }
        if (changes.color) {
            this.instance.setColor(changes.color.currentValue);
        }
        if (changes.lineCap) {
            this.instance.setLineCap(changes.lineCap.currentValue);
        }
        if (changes.lineDash) {
            this.instance.setLineDash(changes.lineDash.currentValue);
        }
        if (changes.lineJoin) {
            this.instance.setLineJoin(changes.lineJoin.currentValue);
        }
        if (changes.miterLimit) {
            this.instance.setMiterLimit(changes.miterLimit.currentValue);
        }
        if (changes.width) {
            this.instance.setWidth(changes.width.currentValue);
        }
        this.host.update();
        // console.log('changes detected in aol-style-stroke, setting new properties: ', changes);
    };
    StyleStrokeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-style-stroke',
                    template: "\n    <div class=\"aol-style-stroke\"></div>\n  "
                }] }
    ];
    /** @nocollapse */
    StyleStrokeComponent.ctorParameters = function () { return [
        { type: StyleComponent, decorators: [{ type: Optional }] },
        { type: StyleCircleComponent, decorators: [{ type: Optional }] },
        { type: StyleTextComponent, decorators: [{ type: Optional }] }
    ]; };
    StyleStrokeComponent.propDecorators = {
        color: [{ type: Input }],
        lineCap: [{ type: Input }],
        lineDash: [{ type: Input }],
        lineJoin: [{ type: Input }],
        miterLimit: [{ type: Input }],
        width: [{ type: Input }]
    };
    return StyleStrokeComponent;
}());
if (false) {
    /** @type {?} */
    StyleStrokeComponent.prototype.instance;
    /**
     * @type {?}
     * @private
     */
    StyleStrokeComponent.prototype.host;
    /** @type {?} */
    StyleStrokeComponent.prototype.color;
    /** @type {?} */
    StyleStrokeComponent.prototype.lineCap;
    /** @type {?} */
    StyleStrokeComponent.prototype.lineDash;
    /** @type {?} */
    StyleStrokeComponent.prototype.lineJoin;
    /** @type {?} */
    StyleStrokeComponent.prototype.miterLimit;
    /** @type {?} */
    StyleStrokeComponent.prototype.width;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StyleIconComponent = /** @class */ (function () {
    function StyleIconComponent(host) {
        this.host = host;
    }
    /**
     * @return {?}
     */
    StyleIconComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // console.log('creating ol.style.Icon instance with: ', this);
        this.instance = new Icon(this);
        this.host.instance.setImage(this.instance);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    StyleIconComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.instance) {
            return;
        }
        if (changes.opacity) {
            this.instance.setOpacity(changes.opacity.currentValue);
        }
        if (changes.rotation) {
            this.instance.setRotation(changes.rotation.currentValue);
        }
        if (changes.scale) {
            this.instance.setScale(changes.scale.currentValue);
        }
        if (changes.src) {
            this.instance = new Icon(this);
            this.host.instance.setImage(this.instance);
        }
        this.host.update();
        // console.log('changes detected in aol-style-icon: ', changes);
    };
    StyleIconComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-style-icon',
                    template: "\n    <div class=\"aol-style-icon\"></div>\n  "
                }] }
    ];
    /** @nocollapse */
    StyleIconComponent.ctorParameters = function () { return [
        { type: StyleComponent, decorators: [{ type: Host }] }
    ]; };
    StyleIconComponent.propDecorators = {
        anchor: [{ type: Input }],
        anchorXUnits: [{ type: Input }],
        anchorYUnits: [{ type: Input }],
        anchorOrigin: [{ type: Input }],
        color: [{ type: Input }],
        crossOrigin: [{ type: Input }],
        img: [{ type: Input }],
        offset: [{ type: Input }],
        offsetOrigin: [{ type: Input }],
        opacity: [{ type: Input }],
        scale: [{ type: Input }],
        snapToPixel: [{ type: Input }],
        rotateWithView: [{ type: Input }],
        rotation: [{ type: Input }],
        size: [{ type: Input }],
        imgSize: [{ type: Input }],
        src: [{ type: Input }]
    };
    return StyleIconComponent;
}());
if (false) {
    /** @type {?} */
    StyleIconComponent.prototype.instance;
    /** @type {?} */
    StyleIconComponent.prototype.anchor;
    /** @type {?} */
    StyleIconComponent.prototype.anchorXUnits;
    /** @type {?} */
    StyleIconComponent.prototype.anchorYUnits;
    /** @type {?} */
    StyleIconComponent.prototype.anchorOrigin;
    /** @type {?} */
    StyleIconComponent.prototype.color;
    /** @type {?} */
    StyleIconComponent.prototype.crossOrigin;
    /** @type {?} */
    StyleIconComponent.prototype.img;
    /** @type {?} */
    StyleIconComponent.prototype.offset;
    /** @type {?} */
    StyleIconComponent.prototype.offsetOrigin;
    /** @type {?} */
    StyleIconComponent.prototype.opacity;
    /** @type {?} */
    StyleIconComponent.prototype.scale;
    /** @type {?} */
    StyleIconComponent.prototype.snapToPixel;
    /** @type {?} */
    StyleIconComponent.prototype.rotateWithView;
    /** @type {?} */
    StyleIconComponent.prototype.rotation;
    /** @type {?} */
    StyleIconComponent.prototype.size;
    /** @type {?} */
    StyleIconComponent.prototype.imgSize;
    /** @type {?} */
    StyleIconComponent.prototype.src;
    /**
     * @type {?}
     * @private
     */
    StyleIconComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StyleFillComponent = /** @class */ (function () {
    function StyleFillComponent(styleHost, styleCircleHost, styleTextHost) {
        if (!styleHost) {
            throw new Error('aol-style-stroke must be a descendant of aol-style');
        }
        if (!!styleTextHost) {
            this.host = styleTextHost;
        }
        else if (!!styleCircleHost) {
            this.host = styleCircleHost;
        }
        else {
            this.host = styleHost;
        }
        // console.log('creating aol-style-fill with: ', this);
    }
    /**
     * @return {?}
     */
    StyleFillComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // console.log('creating ol.style.Fill instance with: ', this);
        this.instance = new Fill(this);
        switch (this.host.componentType) {
            case 'style':
                this.host.instance.setFill(this.instance);
                // console.log('setting ol.style instance\'s fill:', this.host);
                break;
            case 'style-text':
                this.host.instance.setFill(this.instance);
                break;
            case 'style-circle':
                this.host.fill = this.instance;
                // console.log('setting ol.style.circle instance\'s fill:', this.host);
                break;
            default:
                throw new Error('unknown host type: ' + this.host);
            // break;
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    StyleFillComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.instance) {
            return;
        }
        if (changes.color) {
            this.instance.setColor(changes.color.currentValue);
        }
        this.host.update();
        // console.log('changes detected in aol-style-fill, setting new color: ', changes);
    };
    StyleFillComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-style-fill',
                    template: "\n    <div class=\"aol-style-fill\"></div>\n  "
                }] }
    ];
    /** @nocollapse */
    StyleFillComponent.ctorParameters = function () { return [
        { type: StyleComponent, decorators: [{ type: Optional }] },
        { type: StyleCircleComponent, decorators: [{ type: Optional }] },
        { type: StyleTextComponent, decorators: [{ type: Optional }] }
    ]; };
    StyleFillComponent.propDecorators = {
        color: [{ type: Input }]
    };
    return StyleFillComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    StyleFillComponent.prototype.host;
    /** @type {?} */
    StyleFillComponent.prototype.instance;
    /** @type {?} */
    StyleFillComponent.prototype.color;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DefaultControlComponent = /** @class */ (function () {
    function DefaultControlComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    DefaultControlComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // console.log('ol.control.defaults init: ', this);
        this.instance = defaults(this);
        this.instance.forEach((/**
         * @param {?} c
         * @return {?}
         */
        function (c) { return _this.map.instance.addControl(c); }));
    };
    /**
     * @return {?}
     */
    DefaultControlComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // console.log('removing aol-control-defaults');
        this.instance.forEach((/**
         * @param {?} c
         * @return {?}
         */
        function (c) { return _this.map.instance.removeControl(c); }));
    };
    DefaultControlComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-control-defaults',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    DefaultControlComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    DefaultControlComponent.propDecorators = {
        attribution: [{ type: Input }],
        attributionOptions: [{ type: Input }],
        rotate: [{ type: Input }],
        rotateOptions: [{ type: Input }],
        zoom: [{ type: Input }],
        zoomOptions: [{ type: Input }]
    };
    return DefaultControlComponent;
}());
if (false) {
    /** @type {?} */
    DefaultControlComponent.prototype.instance;
    /** @type {?} */
    DefaultControlComponent.prototype.attribution;
    /** @type {?} */
    DefaultControlComponent.prototype.attributionOptions;
    /** @type {?} */
    DefaultControlComponent.prototype.rotate;
    /** @type {?} */
    DefaultControlComponent.prototype.rotateOptions;
    /** @type {?} */
    DefaultControlComponent.prototype.zoom;
    /** @type {?} */
    DefaultControlComponent.prototype.zoomOptions;
    /**
     * @type {?}
     * @private
     */
    DefaultControlComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ControlComponent = /** @class */ (function () {
    function ControlComponent(map) {
        this.map = map;
        this.componentType = 'control';
    }
    /**
     * @return {?}
     */
    ControlComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.content) {
            this.element = this.content.elementRef.nativeElement;
            this.instance = new Control(this);
            this.map.instance.addControl(this.instance);
        }
    };
    /**
     * @return {?}
     */
    ControlComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.instance) {
            this.map.instance.removeControl(this.instance);
        }
    };
    ControlComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-control',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    ControlComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    ControlComponent.propDecorators = {
        content: [{ type: ContentChild, args: [ContentComponent, { static: true },] }]
    };
    return ControlComponent;
}());
if (false) {
    /** @type {?} */
    ControlComponent.prototype.componentType;
    /** @type {?} */
    ControlComponent.prototype.instance;
    /** @type {?} */
    ControlComponent.prototype.element;
    /** @type {?} */
    ControlComponent.prototype.content;
    /**
     * @type {?}
     * @private
     */
    ControlComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ControlAttributionComponent = /** @class */ (function () {
    function ControlAttributionComponent(map, element) {
        this.map = map;
        this.element = element;
        this.componentType = 'control';
    }
    /**
     * @return {?}
     */
    ControlAttributionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.target = this.element.nativeElement;
        // console.log('ol.control.Attribution init: ', this);
        this.instance = new Attribution(this);
        this.map.instance.addControl(this.instance);
    };
    /**
     * @return {?}
     */
    ControlAttributionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // console.log('removing aol-control-attribution');
        this.map.instance.removeControl(this.instance);
    };
    ControlAttributionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-control-attribution',
                    template: ""
                }] }
    ];
    /** @nocollapse */
    ControlAttributionComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: ElementRef }
    ]; };
    ControlAttributionComponent.propDecorators = {
        collapsible: [{ type: Input }]
    };
    return ControlAttributionComponent;
}());
if (false) {
    /** @type {?} */
    ControlAttributionComponent.prototype.componentType;
    /** @type {?} */
    ControlAttributionComponent.prototype.instance;
    /** @type {?} */
    ControlAttributionComponent.prototype.target;
    /** @type {?} */
    ControlAttributionComponent.prototype.collapsible;
    /**
     * @type {?}
     * @private
     */
    ControlAttributionComponent.prototype.map;
    /**
     * @type {?}
     * @private
     */
    ControlAttributionComponent.prototype.element;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ControlFullScreenComponent = /** @class */ (function () {
    function ControlFullScreenComponent(map) {
        this.map = map;
        // console.log('instancing aol-control-fullscreen');
    }
    /**
     * @return {?}
     */
    ControlFullScreenComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new FullScreen(this);
        this.map.instance.addControl(this.instance);
    };
    /**
     * @return {?}
     */
    ControlFullScreenComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // console.log('removing aol-control-fullscreen');
        this.map.instance.removeControl(this.instance);
    };
    ControlFullScreenComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-control-fullscreen',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    ControlFullScreenComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    ControlFullScreenComponent.propDecorators = {
        className: [{ type: Input }],
        label: [{ type: Input }],
        labelActive: [{ type: Input }],
        tipLabel: [{ type: Input }],
        keys: [{ type: Input }]
    };
    return ControlFullScreenComponent;
}());
if (false) {
    /** @type {?} */
    ControlFullScreenComponent.prototype.instance;
    /** @type {?} */
    ControlFullScreenComponent.prototype.className;
    /** @type {?} */
    ControlFullScreenComponent.prototype.label;
    /** @type {?} */
    ControlFullScreenComponent.prototype.labelActive;
    /** @type {?} */
    ControlFullScreenComponent.prototype.tipLabel;
    /** @type {?} */
    ControlFullScreenComponent.prototype.keys;
    /**
     * @type {?}
     * @private
     */
    ControlFullScreenComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ControlMousePositionComponent = /** @class */ (function () {
    function ControlMousePositionComponent(map, element) {
        this.map = map;
        this.element = element;
    }
    /**
     * @return {?}
     */
    ControlMousePositionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.target = this.element.nativeElement;
        // console.log('ol.control.MousePosition init: ', this);
        this.instance = new MousePosition(this);
        this.map.instance.addControl(this.instance);
    };
    /**
     * @return {?}
     */
    ControlMousePositionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // console.log('removing aol-control-mouseposition');
        this.map.instance.removeControl(this.instance);
    };
    ControlMousePositionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-control-mouseposition',
                    template: ""
                }] }
    ];
    /** @nocollapse */
    ControlMousePositionComponent.ctorParameters = function () { return [
        { type: MapComponent },
        { type: ElementRef }
    ]; };
    ControlMousePositionComponent.propDecorators = {
        coordinateFormat: [{ type: Input }],
        projection: [{ type: Input }]
    };
    return ControlMousePositionComponent;
}());
if (false) {
    /** @type {?} */
    ControlMousePositionComponent.prototype.instance;
    /** @type {?} */
    ControlMousePositionComponent.prototype.coordinateFormat;
    /** @type {?} */
    ControlMousePositionComponent.prototype.projection;
    /** @type {?} */
    ControlMousePositionComponent.prototype.target;
    /**
     * @type {?}
     * @private
     */
    ControlMousePositionComponent.prototype.map;
    /**
     * @type {?}
     * @private
     */
    ControlMousePositionComponent.prototype.element;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ControlOverviewMapComponent = /** @class */ (function () {
    function ControlOverviewMapComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ControlOverviewMapComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new OverviewMap(this);
        this.map.instance.addControl(this.instance);
    };
    /**
     * @return {?}
     */
    ControlOverviewMapComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeControl(this.instance);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ControlOverviewMapComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this.instance != null && changes.hasOwnProperty('view')) {
            this.reloadInstance();
        }
    };
    /**
     * @private
     * @return {?}
     */
    ControlOverviewMapComponent.prototype.reloadInstance = /**
     * @private
     * @return {?}
     */
    function () {
        this.map.instance.removeControl(this.instance);
        this.instance = new OverviewMap(this);
        this.map.instance.addControl(this.instance);
    };
    ControlOverviewMapComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-control-overviewmap',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    ControlOverviewMapComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    ControlOverviewMapComponent.propDecorators = {
        collapsed: [{ type: Input }],
        collapseLabel: [{ type: Input }],
        collapsible: [{ type: Input }],
        label: [{ type: Input }],
        layers: [{ type: Input }],
        target: [{ type: Input }],
        tipLabel: [{ type: Input }],
        view: [{ type: Input }]
    };
    return ControlOverviewMapComponent;
}());
if (false) {
    /** @type {?} */
    ControlOverviewMapComponent.prototype.instance;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.collapsed;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.collapseLabel;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.collapsible;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.label;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.layers;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.target;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.tipLabel;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.view;
    /**
     * @type {?}
     * @private
     */
    ControlOverviewMapComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ControlRotateComponent = /** @class */ (function () {
    function ControlRotateComponent(map) {
        this.map = map;
        // console.log('instancing aol-control-rotate');
    }
    /**
     * @return {?}
     */
    ControlRotateComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new Rotate(this);
        this.map.instance.addControl(this.instance);
    };
    /**
     * @return {?}
     */
    ControlRotateComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // console.log('removing aol-control-rotate');
        this.map.instance.removeControl(this.instance);
    };
    ControlRotateComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-control-rotate',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    ControlRotateComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    ControlRotateComponent.propDecorators = {
        className: [{ type: Input }],
        label: [{ type: Input }],
        tipLabel: [{ type: Input }],
        duration: [{ type: Input }],
        autoHide: [{ type: Input }]
    };
    return ControlRotateComponent;
}());
if (false) {
    /** @type {?} */
    ControlRotateComponent.prototype.instance;
    /** @type {?} */
    ControlRotateComponent.prototype.className;
    /** @type {?} */
    ControlRotateComponent.prototype.label;
    /** @type {?} */
    ControlRotateComponent.prototype.tipLabel;
    /** @type {?} */
    ControlRotateComponent.prototype.duration;
    /** @type {?} */
    ControlRotateComponent.prototype.autoHide;
    /**
     * @type {?}
     * @private
     */
    ControlRotateComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ControlScaleLineComponent = /** @class */ (function () {
    function ControlScaleLineComponent(map) {
        this.map = map;
        // console.log('instancing aol-control-scaleline');
    }
    /**
     * @return {?}
     */
    ControlScaleLineComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new ScaleLine(this);
        this.map.instance.addControl(this.instance);
    };
    /**
     * @return {?}
     */
    ControlScaleLineComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // console.log('removing aol-control-scaleline');
        this.map.instance.removeControl(this.instance);
    };
    ControlScaleLineComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-control-scaleline',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    ControlScaleLineComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    ControlScaleLineComponent.propDecorators = {
        units: [{ type: Input }]
    };
    return ControlScaleLineComponent;
}());
if (false) {
    /** @type {?} */
    ControlScaleLineComponent.prototype.instance;
    /** @type {?} */
    ControlScaleLineComponent.prototype.units;
    /**
     * @type {?}
     * @private
     */
    ControlScaleLineComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ControlZoomComponent = /** @class */ (function () {
    function ControlZoomComponent(map) {
        this.map = map;
        // console.log('instancing aol-control-zoom');
    }
    /**
     * @return {?}
     */
    ControlZoomComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new Zoom(this);
        this.map.instance.addControl(this.instance);
    };
    /**
     * @return {?}
     */
    ControlZoomComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // console.log('removing aol-control-zoom');
        this.map.instance.removeControl(this.instance);
    };
    ControlZoomComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-control-zoom',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    ControlZoomComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    ControlZoomComponent.propDecorators = {
        duration: [{ type: Input }],
        zoomInLabel: [{ type: Input }],
        zoomOutLabel: [{ type: Input }],
        zoomInTipLabel: [{ type: Input }],
        zoomOutTipLabel: [{ type: Input }],
        delta: [{ type: Input }]
    };
    return ControlZoomComponent;
}());
if (false) {
    /** @type {?} */
    ControlZoomComponent.prototype.instance;
    /** @type {?} */
    ControlZoomComponent.prototype.duration;
    /** @type {?} */
    ControlZoomComponent.prototype.zoomInLabel;
    /** @type {?} */
    ControlZoomComponent.prototype.zoomOutLabel;
    /** @type {?} */
    ControlZoomComponent.prototype.zoomInTipLabel;
    /** @type {?} */
    ControlZoomComponent.prototype.zoomOutTipLabel;
    /** @type {?} */
    ControlZoomComponent.prototype.delta;
    /**
     * @type {?}
     * @private
     */
    ControlZoomComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ControlZoomSliderComponent = /** @class */ (function () {
    function ControlZoomSliderComponent(map) {
        this.map = map;
        // console.log('instancing aol-control-zoomslider');
    }
    /**
     * @return {?}
     */
    ControlZoomSliderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new ZoomSlider(this);
        this.map.instance.addControl(this.instance);
    };
    /**
     * @return {?}
     */
    ControlZoomSliderComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // console.log('removing aol-control-zoomslider');
        this.map.instance.removeControl(this.instance);
    };
    ControlZoomSliderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-control-zoomslider',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    ControlZoomSliderComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    ControlZoomSliderComponent.propDecorators = {
        className: [{ type: Input }],
        duration: [{ type: Input }],
        maxResolution: [{ type: Input }],
        minResolution: [{ type: Input }]
    };
    return ControlZoomSliderComponent;
}());
if (false) {
    /** @type {?} */
    ControlZoomSliderComponent.prototype.instance;
    /** @type {?} */
    ControlZoomSliderComponent.prototype.className;
    /** @type {?} */
    ControlZoomSliderComponent.prototype.duration;
    /** @type {?} */
    ControlZoomSliderComponent.prototype.maxResolution;
    /** @type {?} */
    ControlZoomSliderComponent.prototype.minResolution;
    /**
     * @type {?}
     * @private
     */
    ControlZoomSliderComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ControlZoomToExtentComponent = /** @class */ (function () {
    function ControlZoomToExtentComponent(map) {
        this.map = map;
        // console.log('instancing aol-control-zoomtoextent');
    }
    /**
     * @return {?}
     */
    ControlZoomToExtentComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new ZoomToExtent(this);
        this.map.instance.addControl(this.instance);
    };
    /**
     * @return {?}
     */
    ControlZoomToExtentComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // console.log('removing aol-control-zoomtoextent');
        this.map.instance.removeControl(this.instance);
    };
    ControlZoomToExtentComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-control-zoomtoextent',
                    template: "\n    <ng-content></ng-content>\n  "
                }] }
    ];
    /** @nocollapse */
    ControlZoomToExtentComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    ControlZoomToExtentComponent.propDecorators = {
        className: [{ type: Input }],
        label: [{ type: Input }],
        tipLabel: [{ type: Input }],
        extent: [{ type: Input }]
    };
    return ControlZoomToExtentComponent;
}());
if (false) {
    /** @type {?} */
    ControlZoomToExtentComponent.prototype.instance;
    /** @type {?} */
    ControlZoomToExtentComponent.prototype.className;
    /** @type {?} */
    ControlZoomToExtentComponent.prototype.label;
    /** @type {?} */
    ControlZoomToExtentComponent.prototype.tipLabel;
    /** @type {?} */
    ControlZoomToExtentComponent.prototype.extent;
    /**
     * @type {?}
     * @private
     */
    ControlZoomToExtentComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FormatMVTComponent = /** @class */ (function (_super) {
    __extends(FormatMVTComponent, _super);
    function FormatMVTComponent() {
        var _this = _super.call(this) || this;
        _this.instance = new MVT(_this);
        return _this;
    }
    FormatMVTComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-format-mvt',
                    template: '',
                    providers: [{ provide: FormatComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return FormatMVTComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    FormatMVTComponent.ctorParameters = function () { return []; };
    FormatMVTComponent.propDecorators = {
        featureClass: [{ type: Input }],
        geometryName: [{ type: Input }],
        layerName: [{ type: Input }],
        layers: [{ type: Input }]
    };
    return FormatMVTComponent;
}(FormatComponent));
if (false) {
    /** @type {?} */
    FormatMVTComponent.prototype.instance;
    /** @type {?} */
    FormatMVTComponent.prototype.featureClass;
    /** @type {?} */
    FormatMVTComponent.prototype.geometryName;
    /** @type {?} */
    FormatMVTComponent.prototype.layerName;
    /** @type {?} */
    FormatMVTComponent.prototype.layers;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DefaultInteractionComponent = /** @class */ (function () {
    function DefaultInteractionComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    DefaultInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance = defaults$1();
        this.instance.forEach((/**
         * @param {?} i
         * @return {?}
         */
        function (i) { return _this.map.instance.addInteraction(i); }));
    };
    /**
     * @return {?}
     */
    DefaultInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance.forEach((/**
         * @param {?} i
         * @return {?}
         */
        function (i) { return _this.map.instance.removeInteraction(i); }));
    };
    DefaultInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-default',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    DefaultInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    return DefaultInteractionComponent;
}());
if (false) {
    /** @type {?} */
    DefaultInteractionComponent.prototype.instance;
    /**
     * @type {?}
     * @private
     */
    DefaultInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DoubleClickZoomInteractionComponent = /** @class */ (function () {
    function DoubleClickZoomInteractionComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    DoubleClickZoomInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new DoubleClickZoom(this);
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    DoubleClickZoomInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    DoubleClickZoomInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-doubleclickzoom',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    DoubleClickZoomInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    DoubleClickZoomInteractionComponent.propDecorators = {
        duration: [{ type: Input }],
        delta: [{ type: Input }]
    };
    return DoubleClickZoomInteractionComponent;
}());
if (false) {
    /** @type {?} */
    DoubleClickZoomInteractionComponent.prototype.instance;
    /** @type {?} */
    DoubleClickZoomInteractionComponent.prototype.duration;
    /** @type {?} */
    DoubleClickZoomInteractionComponent.prototype.delta;
    /**
     * @type {?}
     * @private
     */
    DoubleClickZoomInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DragAndDropInteractionComponent = /** @class */ (function () {
    function DragAndDropInteractionComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    DragAndDropInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new DragAndDrop(this);
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    DragAndDropInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    DragAndDropInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-draganddrop',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    DragAndDropInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    DragAndDropInteractionComponent.propDecorators = {
        formatConstructors: [{ type: Input }],
        projection: [{ type: Input }],
        target: [{ type: Input }]
    };
    return DragAndDropInteractionComponent;
}());
if (false) {
    /** @type {?} */
    DragAndDropInteractionComponent.prototype.instance;
    /** @type {?} */
    DragAndDropInteractionComponent.prototype.formatConstructors;
    /** @type {?} */
    DragAndDropInteractionComponent.prototype.projection;
    /** @type {?} */
    DragAndDropInteractionComponent.prototype.target;
    /**
     * @type {?}
     * @private
     */
    DragAndDropInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DragBoxInteractionComponent = /** @class */ (function () {
    function DragBoxInteractionComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    DragBoxInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new DragBox(this);
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    DragBoxInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    DragBoxInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-dragbox',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    DragBoxInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    DragBoxInteractionComponent.propDecorators = {
        className: [{ type: Input }],
        condition: [{ type: Input }],
        boxEndCondition: [{ type: Input }]
    };
    return DragBoxInteractionComponent;
}());
if (false) {
    /** @type {?} */
    DragBoxInteractionComponent.prototype.instance;
    /** @type {?} */
    DragBoxInteractionComponent.prototype.className;
    /** @type {?} */
    DragBoxInteractionComponent.prototype.condition;
    /** @type {?} */
    DragBoxInteractionComponent.prototype.boxEndCondition;
    /**
     * @type {?}
     * @private
     */
    DragBoxInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DragPanInteractionComponent = /** @class */ (function () {
    function DragPanInteractionComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    DragPanInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new DragPan(this);
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    DragPanInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    DragPanInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-dragpan',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    DragPanInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    DragPanInteractionComponent.propDecorators = {
        condition: [{ type: Input }],
        kinetic: [{ type: Input }]
    };
    return DragPanInteractionComponent;
}());
if (false) {
    /** @type {?} */
    DragPanInteractionComponent.prototype.instance;
    /** @type {?} */
    DragPanInteractionComponent.prototype.condition;
    /** @type {?} */
    DragPanInteractionComponent.prototype.kinetic;
    /**
     * @type {?}
     * @private
     */
    DragPanInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DragRotateInteractionComponent = /** @class */ (function () {
    function DragRotateInteractionComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    DragRotateInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new DragRotate(this);
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    DragRotateInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    DragRotateInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-dragrotate',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    DragRotateInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    DragRotateInteractionComponent.propDecorators = {
        condition: [{ type: Input }],
        duration: [{ type: Input }]
    };
    return DragRotateInteractionComponent;
}());
if (false) {
    /** @type {?} */
    DragRotateInteractionComponent.prototype.instance;
    /** @type {?} */
    DragRotateInteractionComponent.prototype.condition;
    /** @type {?} */
    DragRotateInteractionComponent.prototype.duration;
    /**
     * @type {?}
     * @private
     */
    DragRotateInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DragRotateAndZoomInteractionComponent = /** @class */ (function () {
    function DragRotateAndZoomInteractionComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    DragRotateAndZoomInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new DragRotateAndZoom(this);
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    DragRotateAndZoomInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    DragRotateAndZoomInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-dragrotateandzoom',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    DragRotateAndZoomInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    DragRotateAndZoomInteractionComponent.propDecorators = {
        condition: [{ type: Input }],
        duration: [{ type: Input }]
    };
    return DragRotateAndZoomInteractionComponent;
}());
if (false) {
    /** @type {?} */
    DragRotateAndZoomInteractionComponent.prototype.instance;
    /** @type {?} */
    DragRotateAndZoomInteractionComponent.prototype.condition;
    /** @type {?} */
    DragRotateAndZoomInteractionComponent.prototype.duration;
    /**
     * @type {?}
     * @private
     */
    DragRotateAndZoomInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DragZoomInteractionComponent = /** @class */ (function () {
    function DragZoomInteractionComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    DragZoomInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new DragZoom(this);
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    DragZoomInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    DragZoomInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-dragzoom',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    DragZoomInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    DragZoomInteractionComponent.propDecorators = {
        className: [{ type: Input }],
        condition: [{ type: Input }],
        duration: [{ type: Input }],
        out: [{ type: Input }]
    };
    return DragZoomInteractionComponent;
}());
if (false) {
    /** @type {?} */
    DragZoomInteractionComponent.prototype.instance;
    /** @type {?} */
    DragZoomInteractionComponent.prototype.className;
    /** @type {?} */
    DragZoomInteractionComponent.prototype.condition;
    /** @type {?} */
    DragZoomInteractionComponent.prototype.duration;
    /** @type {?} */
    DragZoomInteractionComponent.prototype.out;
    /**
     * @type {?}
     * @private
     */
    DragZoomInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MouseWheelZoomInteractionComponent = /** @class */ (function () {
    function MouseWheelZoomInteractionComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    MouseWheelZoomInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new MouseWheelZoom(this);
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    MouseWheelZoomInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    MouseWheelZoomInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-mousewheelzoom',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    MouseWheelZoomInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    MouseWheelZoomInteractionComponent.propDecorators = {
        duration: [{ type: Input }],
        timeout: [{ type: Input }],
        useAnchor: [{ type: Input }]
    };
    return MouseWheelZoomInteractionComponent;
}());
if (false) {
    /** @type {?} */
    MouseWheelZoomInteractionComponent.prototype.instance;
    /** @type {?} */
    MouseWheelZoomInteractionComponent.prototype.duration;
    /** @type {?} */
    MouseWheelZoomInteractionComponent.prototype.timeout;
    /** @type {?} */
    MouseWheelZoomInteractionComponent.prototype.useAnchor;
    /**
     * @type {?}
     * @private
     */
    MouseWheelZoomInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PinchZoomInteractionComponent = /** @class */ (function () {
    function PinchZoomInteractionComponent(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    PinchZoomInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new PinchZoom(this);
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    PinchZoomInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    PinchZoomInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-pinchzoom',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    PinchZoomInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    PinchZoomInteractionComponent.propDecorators = {
        duration: [{ type: Input }],
        constrainResolution: [{ type: Input }]
    };
    return PinchZoomInteractionComponent;
}());
if (false) {
    /** @type {?} */
    PinchZoomInteractionComponent.prototype.instance;
    /** @type {?} */
    PinchZoomInteractionComponent.prototype.duration;
    /** @type {?} */
    PinchZoomInteractionComponent.prototype.constrainResolution;
    /**
     * @type {?}
     * @private
     */
    PinchZoomInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DrawInteractionComponent = /** @class */ (function () {
    function DrawInteractionComponent(map) {
        this.map = map;
        this.olChange = new EventEmitter();
        this.olChangeActive = new EventEmitter();
        this.drawEnd = new EventEmitter();
        this.drawStart = new EventEmitter();
        this.propertyChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    DrawInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance = new Draw(this);
        this.instance.on('change', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.olChange.emit(event); }));
        this.instance.on('change:active', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.olChangeActive.emit(event); }));
        this.instance.on('drawend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.drawEnd.emit(event); }));
        this.instance.on('drawstart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.drawStart.emit(event); }));
        this.instance.on('propertychange', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.propertyChange.emit(event); }));
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    DrawInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    DrawInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-draw',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    DrawInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    DrawInteractionComponent.propDecorators = {
        clickTolerance: [{ type: Input }],
        features: [{ type: Input }],
        source: [{ type: Input }],
        snapTolerance: [{ type: Input }],
        type: [{ type: Input }],
        maxPoints: [{ type: Input }],
        minPoints: [{ type: Input }],
        finishCondition: [{ type: Input }],
        style: [{ type: Input }],
        geometryFunction: [{ type: Input }],
        geometryName: [{ type: Input }],
        condition: [{ type: Input }],
        freehandCondition: [{ type: Input }],
        freehand: [{ type: Input }],
        wrapX: [{ type: Input }],
        olChange: [{ type: Output }],
        olChangeActive: [{ type: Output }],
        drawEnd: [{ type: Output }],
        drawStart: [{ type: Output }],
        propertyChange: [{ type: Output }]
    };
    return DrawInteractionComponent;
}());
if (false) {
    /** @type {?} */
    DrawInteractionComponent.prototype.instance;
    /** @type {?} */
    DrawInteractionComponent.prototype.clickTolerance;
    /** @type {?} */
    DrawInteractionComponent.prototype.features;
    /** @type {?} */
    DrawInteractionComponent.prototype.source;
    /** @type {?} */
    DrawInteractionComponent.prototype.snapTolerance;
    /** @type {?} */
    DrawInteractionComponent.prototype.type;
    /** @type {?} */
    DrawInteractionComponent.prototype.maxPoints;
    /** @type {?} */
    DrawInteractionComponent.prototype.minPoints;
    /** @type {?} */
    DrawInteractionComponent.prototype.finishCondition;
    /** @type {?} */
    DrawInteractionComponent.prototype.style;
    /** @type {?} */
    DrawInteractionComponent.prototype.geometryFunction;
    /** @type {?} */
    DrawInteractionComponent.prototype.geometryName;
    /** @type {?} */
    DrawInteractionComponent.prototype.condition;
    /** @type {?} */
    DrawInteractionComponent.prototype.freehandCondition;
    /** @type {?} */
    DrawInteractionComponent.prototype.freehand;
    /** @type {?} */
    DrawInteractionComponent.prototype.wrapX;
    /** @type {?} */
    DrawInteractionComponent.prototype.olChange;
    /** @type {?} */
    DrawInteractionComponent.prototype.olChangeActive;
    /** @type {?} */
    DrawInteractionComponent.prototype.drawEnd;
    /** @type {?} */
    DrawInteractionComponent.prototype.drawStart;
    /** @type {?} */
    DrawInteractionComponent.prototype.propertyChange;
    /**
     * @type {?}
     * @private
     */
    DrawInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SelectInteractionComponent = /** @class */ (function () {
    function SelectInteractionComponent(map) {
        this.map = map;
        this.olChange = new EventEmitter();
        this.olSelect = new EventEmitter();
        this.propertyChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    SelectInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance = new Select(this);
        this.instance.on('change', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.olChange.emit(event); }));
        this.instance.on('select', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.olSelect.emit(event); }));
        this.instance.on('propertychange', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.propertyChange.emit(event); }));
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    SelectInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    SelectInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-select',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    SelectInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    SelectInteractionComponent.propDecorators = {
        addCondition: [{ type: Input }],
        condition: [{ type: Input }],
        layers: [{ type: Input }],
        style: [{ type: Input }],
        removeCondition: [{ type: Input }],
        toggleCondition: [{ type: Input }],
        multi: [{ type: Input }],
        features: [{ type: Input }],
        filter: [{ type: Input }],
        wrapX: [{ type: Input }],
        olChange: [{ type: Output }],
        olSelect: [{ type: Output }],
        propertyChange: [{ type: Output }]
    };
    return SelectInteractionComponent;
}());
if (false) {
    /** @type {?} */
    SelectInteractionComponent.prototype.instance;
    /** @type {?} */
    SelectInteractionComponent.prototype.addCondition;
    /** @type {?} */
    SelectInteractionComponent.prototype.condition;
    /** @type {?} */
    SelectInteractionComponent.prototype.layers;
    /** @type {?} */
    SelectInteractionComponent.prototype.style;
    /** @type {?} */
    SelectInteractionComponent.prototype.removeCondition;
    /** @type {?} */
    SelectInteractionComponent.prototype.toggleCondition;
    /** @type {?} */
    SelectInteractionComponent.prototype.multi;
    /** @type {?} */
    SelectInteractionComponent.prototype.features;
    /** @type {?} */
    SelectInteractionComponent.prototype.filter;
    /** @type {?} */
    SelectInteractionComponent.prototype.wrapX;
    /** @type {?} */
    SelectInteractionComponent.prototype.olChange;
    /** @type {?} */
    SelectInteractionComponent.prototype.olSelect;
    /** @type {?} */
    SelectInteractionComponent.prototype.propertyChange;
    /**
     * @type {?}
     * @private
     */
    SelectInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModifyInteractionComponent = /** @class */ (function () {
    function ModifyInteractionComponent(map) {
        this.map = map;
        this.modifyEnd = new EventEmitter();
        this.modifyStart = new EventEmitter();
        this.olChange = new EventEmitter();
        this.olChangeActive = new EventEmitter();
        this.propertyChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ModifyInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance = new Modify(this);
        this.instance.on('change', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.olChange.emit(event); }));
        this.instance.on('change:active', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.olChangeActive.emit(event); }));
        this.instance.on('propertychange', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.propertyChange.emit(event); }));
        this.instance.on('modifyend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.modifyEnd.emit(event); }));
        this.instance.on('modifystart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.modifyStart.emit(event); }));
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    ModifyInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    ModifyInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-modify',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    ModifyInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    ModifyInteractionComponent.propDecorators = {
        condition: [{ type: Input }],
        deleteCondition: [{ type: Input }],
        pixelTolerance: [{ type: Input }],
        style: [{ type: Input }],
        features: [{ type: Input }],
        wrapX: [{ type: Input }],
        source: [{ type: Input }],
        modifyEnd: [{ type: Output }],
        modifyStart: [{ type: Output }],
        olChange: [{ type: Output }],
        olChangeActive: [{ type: Output }],
        propertyChange: [{ type: Output }]
    };
    return ModifyInteractionComponent;
}());
if (false) {
    /** @type {?} */
    ModifyInteractionComponent.prototype.instance;
    /** @type {?} */
    ModifyInteractionComponent.prototype.condition;
    /** @type {?} */
    ModifyInteractionComponent.prototype.deleteCondition;
    /** @type {?} */
    ModifyInteractionComponent.prototype.pixelTolerance;
    /** @type {?} */
    ModifyInteractionComponent.prototype.style;
    /** @type {?} */
    ModifyInteractionComponent.prototype.features;
    /** @type {?} */
    ModifyInteractionComponent.prototype.wrapX;
    /** @type {?} */
    ModifyInteractionComponent.prototype.source;
    /** @type {?} */
    ModifyInteractionComponent.prototype.modifyEnd;
    /** @type {?} */
    ModifyInteractionComponent.prototype.modifyStart;
    /** @type {?} */
    ModifyInteractionComponent.prototype.olChange;
    /** @type {?} */
    ModifyInteractionComponent.prototype.olChangeActive;
    /** @type {?} */
    ModifyInteractionComponent.prototype.propertyChange;
    /**
     * @type {?}
     * @private
     */
    ModifyInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TranslateInteractionComponent = /** @class */ (function () {
    function TranslateInteractionComponent(map) {
        this.map = map;
        this.olChange = new EventEmitter();
        this.propertyChange = new EventEmitter();
        this.translateEnd = new EventEmitter();
        this.translateStart = new EventEmitter();
        this.translating = new EventEmitter();
    }
    /**
     * @return {?}
     */
    TranslateInteractionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.instance = new Translate(this);
        this.instance.on('change', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.olChange.emit(event); }));
        this.instance.on('propertychange', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.propertyChange.emit(event); }));
        this.instance.on('translateend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.translateEnd.emit(event); }));
        this.instance.on('translatestart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.translateStart.emit(event); }));
        this.instance.on('translating', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.translating.emit(event); }));
        this.map.instance.addInteraction(this.instance);
    };
    /**
     * @return {?}
     */
    TranslateInteractionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.instance.removeInteraction(this.instance);
    };
    TranslateInteractionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-interaction-translate',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    TranslateInteractionComponent.ctorParameters = function () { return [
        { type: MapComponent }
    ]; };
    TranslateInteractionComponent.propDecorators = {
        features: [{ type: Input }],
        layers: [{ type: Input }],
        hitTolerance: [{ type: Input }],
        olChange: [{ type: Output }],
        propertyChange: [{ type: Output }],
        translateEnd: [{ type: Output }],
        translateStart: [{ type: Output }],
        translating: [{ type: Output }]
    };
    return TranslateInteractionComponent;
}());
if (false) {
    /** @type {?} */
    TranslateInteractionComponent.prototype.instance;
    /** @type {?} */
    TranslateInteractionComponent.prototype.features;
    /** @type {?} */
    TranslateInteractionComponent.prototype.layers;
    /** @type {?} */
    TranslateInteractionComponent.prototype.hitTolerance;
    /** @type {?} */
    TranslateInteractionComponent.prototype.olChange;
    /** @type {?} */
    TranslateInteractionComponent.prototype.propertyChange;
    /** @type {?} */
    TranslateInteractionComponent.prototype.translateEnd;
    /** @type {?} */
    TranslateInteractionComponent.prototype.translateStart;
    /** @type {?} */
    TranslateInteractionComponent.prototype.translating;
    /**
     * @type {?}
     * @private
     */
    TranslateInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AttributionComponent = /** @class */ (function () {
    function AttributionComponent(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    AttributionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.html = this.elementRef.nativeElement.innerHTML;
        this.instance = new Attribution(this);
    };
    AttributionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-attribution',
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    AttributionComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return AttributionComponent;
}());
if (false) {
    /** @type {?} */
    AttributionComponent.prototype.instance;
    /** @type {?} */
    AttributionComponent.prototype.html;
    /**
     * @type {?}
     * @private
     */
    AttributionComponent.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AttributionsComponent = /** @class */ (function () {
    function AttributionsComponent(source) {
        this.source = source;
    }
    /* we can do this at the very end */
    /* we can do this at the very end */
    /**
     * @return {?}
     */
    AttributionsComponent.prototype.ngAfterViewInit = /* we can do this at the very end */
    /**
     * @return {?}
     */
    function () {
        if (this.attributions.length) {
            this.instance = this.attributions.map((/**
             * @param {?} cmp
             * @return {?}
             */
            function (cmp) { return cmp.instance; }));
            // console.log('setting attributions:', this.instance);
            this.source.instance.setAttributions(this.instance);
        }
    };
    AttributionsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-attributions',
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    AttributionsComponent.ctorParameters = function () { return [
        { type: SourceComponent, decorators: [{ type: Host }] }
    ]; };
    AttributionsComponent.propDecorators = {
        attributions: [{ type: ContentChildren, args: [AttributionComponent,] }]
    };
    return AttributionsComponent;
}());
if (false) {
    /** @type {?} */
    AttributionsComponent.prototype.instance;
    /** @type {?} */
    AttributionsComponent.prototype.attributions;
    /**
     * @type {?}
     * @private
     */
    AttributionsComponent.prototype.source;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SourceUTFGridComponent = /** @class */ (function (_super) {
    __extends(SourceUTFGridComponent, _super);
    function SourceUTFGridComponent(layer) {
        return _super.call(this, layer) || this;
    }
    /**
     * @return {?}
     */
    SourceUTFGridComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.instance = new UTFGrid(this);
        this.host.instance.setSource(this.instance);
    };
    SourceUTFGridComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aol-source-utfgrid',
                    template: "\n    <ng-content></ng-content>\n  ",
                    providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SourceUTFGridComponent; })) }]
                }] }
    ];
    /** @nocollapse */
    SourceUTFGridComponent.ctorParameters = function () { return [
        { type: LayerTileComponent, decorators: [{ type: Host }] }
    ]; };
    SourceUTFGridComponent.propDecorators = {
        tileJSON: [{ type: Input }],
        url: [{ type: Input }]
    };
    return SourceUTFGridComponent;
}(SourceComponent));
if (false) {
    /** @type {?} */
    SourceUTFGridComponent.prototype.instance;
    /** @type {?} */
    SourceUTFGridComponent.prototype.tileJSON;
    /** @type {?} */
    SourceUTFGridComponent.prototype.url;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var COMPONENTS = [
    MapComponent,
    ViewComponent,
    GraticuleComponent,
    LayerGroupComponent,
    LayerImageComponent,
    LayerTileComponent,
    LayerVectorComponent,
    LayerVectorTileComponent,
    SourceOsmComponent,
    SourceBingmapsComponent,
    SourceClusterComponent,
    SourceUTFGridComponent,
    SourceVectorComponent,
    SourceXYZComponent,
    SourceVectorTileComponent,
    SourceTileWMSComponent,
    SourceTileWMTSComponent,
    SourceTileJSONComponent,
    SourceGeoJSONComponent,
    SourceImageStaticComponent,
    SourceImageWMSComponent,
    SourceImageArcGISRestComponent,
    SourceRasterComponent,
    FeatureComponent,
    GeometryLinestringComponent,
    GeometryMultiLinestringComponent,
    GeometryMultiPointComponent,
    GeometryMultiPolygonComponent,
    GeometryPointComponent,
    GeometryPolygonComponent,
    GeometryCircleComponent,
    CoordinateComponent,
    CollectionCoordinatesComponent,
    StyleComponent,
    StyleCircleComponent,
    StyleFillComponent,
    StyleIconComponent,
    StyleStrokeComponent,
    StyleTextComponent,
    DefaultControlComponent,
    ControlComponent,
    ControlAttributionComponent,
    ControlFullScreenComponent,
    ControlMousePositionComponent,
    ControlOverviewMapComponent,
    ControlRotateComponent,
    ControlScaleLineComponent,
    ControlZoomComponent,
    ControlZoomSliderComponent,
    ControlZoomToExtentComponent,
    FormatMVTComponent,
    TileGridComponent,
    TileGridWMTSComponent,
    DefaultInteractionComponent,
    DoubleClickZoomInteractionComponent,
    DragAndDropInteractionComponent,
    DragBoxInteractionComponent,
    DragPanInteractionComponent,
    DragRotateInteractionComponent,
    DragRotateAndZoomInteractionComponent,
    DragZoomInteractionComponent,
    MouseWheelZoomInteractionComponent,
    PinchZoomInteractionComponent,
    DrawInteractionComponent,
    SelectInteractionComponent,
    ModifyInteractionComponent,
    TranslateInteractionComponent,
    OverlayComponent,
    ContentComponent,
    AttributionsComponent,
    AttributionComponent,
];
var AngularOpenlayersModule = /** @class */ (function () {
    function AngularOpenlayersModule() {
    }
    AngularOpenlayersModule.decorators = [
        { type: NgModule, args: [{
                    declarations: COMPONENTS,
                    imports: [CommonModule],
                    exports: COMPONENTS,
                },] }
    ];
    return AngularOpenlayersModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AngularOpenlayersModule, AttributionComponent, AttributionsComponent, CollectionCoordinatesComponent, ContentComponent, ControlAttributionComponent, ControlComponent, ControlFullScreenComponent, ControlMousePositionComponent, ControlOverviewMapComponent, ControlRotateComponent, ControlScaleLineComponent, ControlZoomComponent, ControlZoomSliderComponent, ControlZoomToExtentComponent, CoordinateComponent, DefaultControlComponent, DefaultInteractionComponent, DoubleClickZoomInteractionComponent, DragAndDropInteractionComponent, DragBoxInteractionComponent, DragPanInteractionComponent, DragRotateAndZoomInteractionComponent, DragRotateInteractionComponent, DragZoomInteractionComponent, DrawInteractionComponent, FeatureComponent, FormatMVTComponent, GeometryCircleComponent, GeometryLinestringComponent, GeometryMultiLinestringComponent, GeometryMultiPointComponent, GeometryMultiPolygonComponent, GeometryPointComponent, GeometryPolygonComponent, GraticuleComponent, LayerGroupComponent, LayerImageComponent, LayerTileComponent, LayerVectorComponent, LayerVectorTileComponent, MapComponent, ModifyInteractionComponent, MouseWheelZoomInteractionComponent, OverlayComponent, PinchZoomInteractionComponent, SelectInteractionComponent, SourceBingmapsComponent, SourceClusterComponent, SourceGeoJSONComponent, SourceImageArcGISRestComponent, SourceImageStaticComponent, SourceImageWMSComponent, SourceOsmComponent, SourceRasterComponent, SourceTileJSONComponent, SourceTileWMSComponent, SourceTileWMTSComponent, SourceUTFGridComponent, SourceVectorComponent, SourceVectorTileComponent, SourceXYZComponent, StyleCircleComponent, StyleComponent, StyleFillComponent, StyleIconComponent, StyleStrokeComponent, StyleTextComponent, TileGridComponent, TileGridWMTSComponent, TranslateInteractionComponent, ViewComponent, LayerComponent as a, SourceComponent as b, FormatComponent as c, SimpleGeometryComponent as d };
//# sourceMappingURL=ngx-openlayers.js.map
