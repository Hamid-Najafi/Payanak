import { EventEmitter, Component, ElementRef, Input, Output, SkipSelf, Optional, forwardRef, Host, ContentChild, ContentChildren, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import View from 'ol/View';
import Map from 'ol/Map';
import 'ol/extent';
import 'ol/coordinate';
import { Graticule, VectorTile as VectorTile$1, Feature, Overlay } from 'ol';
import { Style, Circle as Circle$1, Text, Stroke, Icon, Fill } from 'ol/style';
import { Group, Image, Tile, Vector, VectorTile } from 'ol/layer';
import { Raster, XYZ, OSM, BingMaps, Vector as Vector$1, Cluster, WMTS as WMTS$1, TileWMS, TileJSON, ImageStatic, ImageWMS, ImageArcGISRest, UTFGrid } from 'ol/source';
import { createXYZ } from 'ol/tilegrid';
import TileGrid from 'ol/tilegrid/TileGrid';
import 'ol/source/Raster';
import 'ol/Tile';
import 'ol/source/Source';
import 'ol/format/Feature';
import 'ol/source/Vector';
import WMTS from 'ol/tilegrid/WMTS';
import { transform } from 'ol/proj';
import { GeoJSON, MVT } from 'ol/format';
import 'ol/Image';
import 'ol/size';
import { Circle, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon } from 'ol/geom';
import 'ol/color';
import 'ol/style/IconAnchorUnits';
import 'ol/style/IconOrigin';
import { defaults, Control, Attribution, FullScreen, OverviewMap, Rotate, ScaleLine, Zoom, ZoomSlider, ZoomToExtent } from 'ol/control';
import 'ol/control/Attribution';
import 'ol/control/Rotate';
import 'ol/control/Zoom';
import MousePosition from 'ol/control/MousePosition';
import { defaults as defaults$1, DoubleClickZoom, DragAndDrop, DragBox, DragPan, DragRotate, DragRotateAndZoom, DragZoom, MouseWheelZoom, PinchZoom, Draw, Select, Modify, Translate } from 'ol/interaction';
import 'ol/events/condition';
import 'ol/interaction/DragBox';
import 'ol/Kinetic';
import 'ol/geom/GeometryType';
import 'ol/interaction/Draw';
import 'ol/interaction/Select';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MapComponent {
    /**
     * @param {?} host
     */
    constructor(host) {
        this.host = host;
        this.componentType = 'map';
        this.width = '100%';
        this.height = '100%';
        // we pass empty arrays to not get default controls/interactions because we have our own directives
        this.controls = [];
        this.interactions = [];
        this.olClick = new EventEmitter();
        this.dblClick = new EventEmitter();
        this.moveStart = new EventEmitter();
        this.moveEnd = new EventEmitter();
        this.pointerDrag = new EventEmitter();
        this.pointerMove = new EventEmitter();
        this.onpostrender = new EventEmitter();
        this.postRender = new EventEmitter();
        this.onprerender = new EventEmitter();
        this.propertyChange = new EventEmitter();
        this.singleClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('creating ol.Map instance with:', this);
        this.instance = new Map(this);
        this.instance.setTarget(this.host.nativeElement.firstElementChild);
        this.instance.on('click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.olClick.emit(event)));
        this.instance.on('dblclick', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.dblClick.emit(event)));
        this.instance.on('movestart', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.moveStart.emit(event)));
        this.instance.on('moveend', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.moveEnd.emit(event)));
        this.instance.on('pointerdrag', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.pointerDrag.emit(event)));
        this.instance.on('pointermove', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.pointerMove.emit(event)));
        this.instance.on('postrender', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.onpostrender.emit(event)));
        this.instance.on('postrender', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.postRender.emit(event)));
        this.instance.on('prerender', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.onprerender.emit(event)));
        this.instance.on('propertychange', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.propertyChange.emit(event)));
        this.instance.on('singleclick', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.singleClick.emit(event)));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const properties = {};
        if (!this.instance) {
            return;
        }
        for (const key in changes) {
            if (changes.hasOwnProperty(key)) {
                properties[key] = changes[key].currentValue;
            }
        }
        // console.log('changes detected in aol-map, setting new properties: ', properties);
        this.instance.setProperties(properties, false);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.instance.updateSize();
    }
}
MapComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-map',
                template: `
    <div [style.width]="width" [style.height]="height"></div>
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
MapComponent.ctorParameters = () => [
    { type: ElementRef }
];
MapComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    pixelRatio: [{ type: Input }],
    keyboardEventTarget: [{ type: Input }],
    loadTilesWhileAnimating: [{ type: Input }],
    loadTilesWhileInteracting: [{ type: Input }],
    logo: [{ type: Input }],
    renderer: [{ type: Input }],
    olClick: [{ type: Output }],
    dblClick: [{ type: Output }],
    moveStart: [{ type: Output }],
    moveEnd: [{ type: Output }],
    pointerDrag: [{ type: Output }],
    pointerMove: [{ type: Output }],
    onpostrender: [{ type: Output }],
    postRender: [{ type: Output }],
    onprerender: [{ type: Output }],
    propertyChange: [{ type: Output }],
    singleClick: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    MapComponent.prototype.instance;
    /** @type {?} */
    MapComponent.prototype.componentType;
    /** @type {?} */
    MapComponent.prototype.width;
    /** @type {?} */
    MapComponent.prototype.height;
    /** @type {?} */
    MapComponent.prototype.pixelRatio;
    /** @type {?} */
    MapComponent.prototype.keyboardEventTarget;
    /** @type {?} */
    MapComponent.prototype.loadTilesWhileAnimating;
    /** @type {?} */
    MapComponent.prototype.loadTilesWhileInteracting;
    /** @type {?} */
    MapComponent.prototype.logo;
    /** @type {?} */
    MapComponent.prototype.renderer;
    /** @type {?} */
    MapComponent.prototype.olClick;
    /** @type {?} */
    MapComponent.prototype.dblClick;
    /** @type {?} */
    MapComponent.prototype.moveStart;
    /** @type {?} */
    MapComponent.prototype.moveEnd;
    /** @type {?} */
    MapComponent.prototype.pointerDrag;
    /** @type {?} */
    MapComponent.prototype.pointerMove;
    /** @type {?} */
    MapComponent.prototype.onpostrender;
    /** @type {?} */
    MapComponent.prototype.postRender;
    /** @type {?} */
    MapComponent.prototype.onprerender;
    /** @type {?} */
    MapComponent.prototype.propertyChange;
    /** @type {?} */
    MapComponent.prototype.singleClick;
    /** @type {?} */
    MapComponent.prototype.controls;
    /** @type {?} */
    MapComponent.prototype.interactions;
    /**
     * @type {?}
     * @private
     */
    MapComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewComponent {
    /**
     * @param {?} host
     */
    constructor(host) {
        this.host = host;
        this.componentType = 'view';
        this.zoomAnimation = false;
        this.changeZoom = new EventEmitter();
        this.changeResolution = new EventEmitter();
        this.changeCenter = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('creating ol.View instance with: ', this);
        this.instance = new View(this);
        this.host.instance.setView(this.instance);
        this.instance.on('change:zoom', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.changeZoom.emit(event)));
        this.instance.on('change:resolution', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.changeResolution.emit(event)));
        this.instance.on('change:center', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.changeCenter.emit(event)));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const properties = {};
        if (!this.instance) {
            return;
        }
        for (const key in changes) {
            if (changes.hasOwnProperty(key)) {
                switch (key) {
                    case 'zoom':
                        /** Work-around: setting the zoom via setProperties does not work. */
                        if (this.zoomAnimation) {
                            this.instance.animate({ zoom: changes[key].currentValue });
                        }
                        else {
                            this.instance.setZoom(changes[key].currentValue);
                        }
                        break;
                    case 'projection':
                        this.instance = new View(this);
                        this.host.instance.setView(this.instance);
                        break;
                    default:
                        break;
                }
                properties[key] = changes[key].currentValue;
            }
        }
        // console.log('changes detected in aol-view, setting new properties: ', properties);
        this.instance.setProperties(properties, false);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('removing aol-view');
    }
}
ViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-view',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
ViewComponent.ctorParameters = () => [
    { type: MapComponent }
];
ViewComponent.propDecorators = {
    constrainRotation: [{ type: Input }],
    enableRotation: [{ type: Input }],
    extent: [{ type: Input }],
    maxResolution: [{ type: Input }],
    minResolution: [{ type: Input }],
    maxZoom: [{ type: Input }],
    minZoom: [{ type: Input }],
    resolution: [{ type: Input }],
    resolutions: [{ type: Input }],
    rotation: [{ type: Input }],
    zoom: [{ type: Input }],
    zoomFactor: [{ type: Input }],
    center: [{ type: Input }],
    projection: [{ type: Input }],
    zoomAnimation: [{ type: Input }],
    changeZoom: [{ type: Output }],
    changeResolution: [{ type: Output }],
    changeCenter: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    ViewComponent.prototype.instance;
    /** @type {?} */
    ViewComponent.prototype.componentType;
    /** @type {?} */
    ViewComponent.prototype.constrainRotation;
    /** @type {?} */
    ViewComponent.prototype.enableRotation;
    /** @type {?} */
    ViewComponent.prototype.extent;
    /** @type {?} */
    ViewComponent.prototype.maxResolution;
    /** @type {?} */
    ViewComponent.prototype.minResolution;
    /** @type {?} */
    ViewComponent.prototype.maxZoom;
    /** @type {?} */
    ViewComponent.prototype.minZoom;
    /** @type {?} */
    ViewComponent.prototype.resolution;
    /** @type {?} */
    ViewComponent.prototype.resolutions;
    /** @type {?} */
    ViewComponent.prototype.rotation;
    /** @type {?} */
    ViewComponent.prototype.zoom;
    /** @type {?} */
    ViewComponent.prototype.zoomFactor;
    /** @type {?} */
    ViewComponent.prototype.center;
    /** @type {?} */
    ViewComponent.prototype.projection;
    /** @type {?} */
    ViewComponent.prototype.zoomAnimation;
    /** @type {?} */
    ViewComponent.prototype.changeZoom;
    /** @type {?} */
    ViewComponent.prototype.changeResolution;
    /** @type {?} */
    ViewComponent.prototype.changeCenter;
    /**
     * @type {?}
     * @private
     */
    ViewComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GraticuleComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        this.componentType = 'graticule';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const properties = {};
        if (!this.instance) {
            return;
        }
        for (const key in changes) {
            if (changes.hasOwnProperty(key)) {
                properties[key] = changes[key].currentValue;
            }
        }
        if (properties) {
            this.instance = new Graticule(properties);
        }
        this.instance.setMap(this.map.instance);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.instance = new Graticule({
            strokeStyle: this.strokeStyle,
            showLabels: this.showLabels,
            lonLabelPosition: this.lonLabelPosition,
            latLabelPosition: this.latLabelPosition,
        });
        this.instance.setMap(this.map.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.instance.setMap(null);
    }
}
GraticuleComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-graticule',
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
GraticuleComponent.ctorParameters = () => [
    { type: MapComponent }
];
GraticuleComponent.propDecorators = {
    strokeStyle: [{ type: Input }],
    showLabels: [{ type: Input }],
    lonLabelPosition: [{ type: Input }],
    latLabelPosition: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    GraticuleComponent.prototype.instance;
    /** @type {?} */
    GraticuleComponent.prototype.componentType;
    /** @type {?} */
    GraticuleComponent.prototype.strokeStyle;
    /** @type {?} */
    GraticuleComponent.prototype.showLabels;
    /** @type {?} */
    GraticuleComponent.prototype.lonLabelPosition;
    /** @type {?} */
    GraticuleComponent.prototype.latLabelPosition;
    /**
     * @type {?}
     * @private
     */
    GraticuleComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class LayerComponent {
    /**
     * @param {?} host
     */
    constructor(host) {
        this.host = host;
        this.componentType = 'layer';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.prerender !== null && this.prerender !== undefined) {
            this.instance.on('prerender', this.prerender);
        }
        if (this.postrender !== null && this.postrender !== undefined) {
            this.instance.on('postrender', this.postrender);
        }
        this.host.instance.getLayers().push(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.host.instance.getLayers().remove(this.instance);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const properties = {};
        if (!this.instance) {
            return;
        }
        for (const key in changes) {
            if (changes.hasOwnProperty(key)) {
                properties[key] = changes[key].currentValue;
                if (key === 'prerender') {
                    this.instance.un('prerender', changes[key].previousValue);
                    this.instance.on('prerender', changes[key].currentValue);
                }
                if (key === 'postrender') {
                    this.instance.un('postrender', changes[key].previousValue);
                    this.instance.on('postrender', changes[key].currentValue);
                }
            }
        }
        // console.log('changes detected in aol-layer, setting new properties: ', properties);
        this.instance.setProperties(properties, false);
    }
}
LayerComponent.propDecorators = {
    opacity: [{ type: Input }],
    visible: [{ type: Input }],
    extent: [{ type: Input }],
    zIndex: [{ type: Input }],
    minResolution: [{ type: Input }],
    maxResolution: [{ type: Input }],
    prerender: [{ type: Input }],
    postrender: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    LayerComponent.prototype.instance;
    /** @type {?} */
    LayerComponent.prototype.componentType;
    /** @type {?} */
    LayerComponent.prototype.opacity;
    /** @type {?} */
    LayerComponent.prototype.visible;
    /** @type {?} */
    LayerComponent.prototype.extent;
    /** @type {?} */
    LayerComponent.prototype.zIndex;
    /** @type {?} */
    LayerComponent.prototype.minResolution;
    /** @type {?} */
    LayerComponent.prototype.maxResolution;
    /** @type {?} */
    LayerComponent.prototype.prerender;
    /** @type {?} */
    LayerComponent.prototype.postrender;
    /**
     * @type {?}
     * @protected
     */
    LayerComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayerGroupComponent extends LayerComponent {
    /**
     * @param {?} map
     * @param {?=} group
     */
    constructor(map, group) {
        super(group || map);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log(`creating ol.layer.Group instance with:`, this);
        this.instance = new Group(this);
        super.ngOnInit();
    }
}
LayerGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-layer-group',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
LayerGroupComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: LayerGroupComponent, decorators: [{ type: SkipSelf }, { type: Optional }] }
];
if (false) {
    /** @type {?} */
    LayerGroupComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayerImageComponent extends LayerComponent {
    /**
     * @param {?} map
     * @param {?=} group
     */
    constructor(map, group) {
        super(group || map);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new Image(this);
        super.ngOnInit();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
    }
}
LayerImageComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-layer-image',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
LayerImageComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: LayerGroupComponent, decorators: [{ type: Optional }] }
];
LayerImageComponent.propDecorators = {
    opacity: [{ type: Input }],
    visible: [{ type: Input }],
    extent: [{ type: Input }],
    minResolution: [{ type: Input }],
    maxResolution: [{ type: Input }],
    zIndex: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    LayerImageComponent.prototype.source;
    /** @type {?} */
    LayerImageComponent.prototype.opacity;
    /** @type {?} */
    LayerImageComponent.prototype.visible;
    /** @type {?} */
    LayerImageComponent.prototype.extent;
    /** @type {?} */
    LayerImageComponent.prototype.minResolution;
    /** @type {?} */
    LayerImageComponent.prototype.maxResolution;
    /** @type {?} */
    LayerImageComponent.prototype.zIndex;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayerTileComponent extends LayerComponent {
    /**
     * @param {?} map
     * @param {?=} group
     */
    constructor(map, group) {
        super(group || map);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('creating ol.layer.Tile instance with:', this);
        this.instance = new Tile(this);
        super.ngOnInit();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
    }
}
LayerTileComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-layer-tile',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
LayerTileComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: LayerGroupComponent, decorators: [{ type: Optional }] }
];
LayerTileComponent.propDecorators = {
    preload: [{ type: Input }],
    useInterimTilesOnError: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    LayerTileComponent.prototype.source;
    /** @type {?} */
    LayerTileComponent.prototype.preload;
    /** @type {?} */
    LayerTileComponent.prototype.useInterimTilesOnError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayerVectorComponent extends LayerComponent {
    /**
     * @param {?} map
     * @param {?=} group
     */
    constructor(map, group) {
        super(group || map);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('creating ol.layer.Vector instance with:', this);
        this.instance = new Vector(this);
        super.ngOnInit();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
    }
}
LayerVectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-layer-vector',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
LayerVectorComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: LayerGroupComponent, decorators: [{ type: Optional }] }
];
LayerVectorComponent.propDecorators = {
    renderBuffer: [{ type: Input }],
    style: [{ type: Input }],
    updateWhileAnimating: [{ type: Input }],
    updateWhileInteracting: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    LayerVectorComponent.prototype.source;
    /** @type {?} */
    LayerVectorComponent.prototype.renderBuffer;
    /** @type {?} */
    LayerVectorComponent.prototype.style;
    /** @type {?} */
    LayerVectorComponent.prototype.updateWhileAnimating;
    /** @type {?} */
    LayerVectorComponent.prototype.updateWhileInteracting;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayerVectorTileComponent extends LayerComponent {
    /**
     * @param {?} map
     * @param {?=} group
     */
    constructor(map, group) {
        super(group || map);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('creating ol.layer.VectorTile instance with:', this);
        this.instance = new VectorTile(this);
        super.ngOnInit();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
    }
}
LayerVectorTileComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-layer-vectortile',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
LayerVectorTileComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: LayerGroupComponent, decorators: [{ type: Optional }] }
];
LayerVectorTileComponent.propDecorators = {
    renderBuffer: [{ type: Input }],
    renderMode: [{ type: Input }],
    renderOrder: [{ type: Input }],
    style: [{ type: Input }],
    updateWhileAnimating: [{ type: Input }],
    updateWhileInteracting: [{ type: Input }],
    visible: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    LayerVectorTileComponent.prototype.renderBuffer;
    /** @type {?} */
    LayerVectorTileComponent.prototype.renderMode;
    /** @type {?} */
    LayerVectorTileComponent.prototype.renderOrder;
    /** @type {?} */
    LayerVectorTileComponent.prototype.style;
    /** @type {?} */
    LayerVectorTileComponent.prototype.updateWhileAnimating;
    /** @type {?} */
    LayerVectorTileComponent.prototype.updateWhileInteracting;
    /** @type {?} */
    LayerVectorTileComponent.prototype.visible;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceComponent {
    /**
     * @param {?} host
     * @param {?=} raster
     */
    constructor(host, raster) {
        this.host = host;
        this.raster = raster;
        this.componentType = 'source';
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.host && this.host.instance) {
            this.host.instance.setSource(null);
        }
        if (this.raster) {
            this.raster.sources = [];
        }
    }
    /**
     * @protected
     * @param {?} s
     * @return {?}
     */
    _register(s) {
        if (this.host) {
            this.host.instance.setSource(s);
        }
        if (this.raster) {
            this.raster.sources = [s];
            this.raster.init();
        }
    }
}
SourceComponent.propDecorators = {
    attributions: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    SourceComponent.prototype.instance;
    /** @type {?} */
    SourceComponent.prototype.componentType;
    /** @type {?} */
    SourceComponent.prototype.attributions;
    /**
     * @type {?}
     * @protected
     */
    SourceComponent.prototype.host;
    /**
     * @type {?}
     * @protected
     */
    SourceComponent.prototype.raster;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TileGridComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.resolutions) {
            this.instance = createXYZ(this);
        }
        else {
            this.instance = new TileGrid(this);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.resolutions) {
            this.instance = createXYZ(this);
        }
        else {
            this.instance = new TileGrid(this);
        }
    }
}
TileGridComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-tilegrid',
                template: ''
            }] }
];
TileGridComponent.propDecorators = {
    extent: [{ type: Input }],
    maxZoom: [{ type: Input }],
    minZoom: [{ type: Input }],
    tileSize: [{ type: Input }],
    origin: [{ type: Input }],
    resolutions: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TileGridComponent.prototype.instance;
    /** @type {?} */
    TileGridComponent.prototype.extent;
    /** @type {?} */
    TileGridComponent.prototype.maxZoom;
    /** @type {?} */
    TileGridComponent.prototype.minZoom;
    /** @type {?} */
    TileGridComponent.prototype.tileSize;
    /** @type {?} */
    TileGridComponent.prototype.origin;
    /** @type {?} */
    TileGridComponent.prototype.resolutions;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceRasterComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
        this.beforeOperations = new EventEmitter();
        this.afterOperations = new EventEmitter();
        this.sources = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.init();
    }
    /**
     * @return {?}
     */
    init() {
        this.instance = new Raster(this);
        this.instance.on('beforeoperations', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.beforeOperations.emit(event)));
        this.instance.on('afteroperations', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.afterOperations.emit(event)));
        this._register(this.instance);
    }
}
SourceRasterComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-raster',
                template: `
    <ng-content></ng-content>
  `,
                providers: [
                    {
                        provide: SourceComponent,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceRasterComponent)),
                    },
                ]
            }] }
];
/** @nocollapse */
SourceRasterComponent.ctorParameters = () => [
    { type: LayerImageComponent, decorators: [{ type: Host }] }
];
SourceRasterComponent.propDecorators = {
    operation: [{ type: Input }],
    threads: [{ type: Input }],
    lib: [{ type: Input }],
    operationType: [{ type: Input }],
    beforeOperations: [{ type: Output }],
    afterOperations: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SourceRasterComponent.prototype.instance;
    /** @type {?} */
    SourceRasterComponent.prototype.operation;
    /** @type {?} */
    SourceRasterComponent.prototype.threads;
    /** @type {?} */
    SourceRasterComponent.prototype.lib;
    /** @type {?} */
    SourceRasterComponent.prototype.operationType;
    /** @type {?} */
    SourceRasterComponent.prototype.beforeOperations;
    /** @type {?} */
    SourceRasterComponent.prototype.afterOperations;
    /** @type {?} */
    SourceRasterComponent.prototype.sources;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceXYZComponent extends SourceComponent {
    /**
     * @param {?} layer
     * @param {?=} raster
     */
    constructor(layer, raster) {
        super(layer, raster);
        this.tileLoadStart = new EventEmitter();
        this.tileLoadEnd = new EventEmitter();
        this.tileLoadError = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.tileGridXYZ) {
            this.tileGrid = this.tileGridXYZ.instance;
        }
        this.init();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const properties = {};
        if (!this.instance) {
            return;
        }
        for (const key in changes) {
            if (changes.hasOwnProperty(key)) {
                properties[key] = changes[key].currentValue;
            }
        }
        this.instance.setProperties(properties, false);
        if (changes.hasOwnProperty('url')) {
            this.init();
        }
    }
    /**
     * @return {?}
     */
    init() {
        this.instance = new XYZ(this);
        this.instance.on('tileloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.tileLoadStart.emit(event)));
        this.instance.on('tileloadend', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.tileLoadEnd.emit(event)));
        this.instance.on('tileloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.tileLoadError.emit(event)));
        this._register(this.instance);
    }
}
SourceXYZComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-xyz',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceXYZComponent)) }]
            }] }
];
/** @nocollapse */
SourceXYZComponent.ctorParameters = () => [
    { type: LayerTileComponent, decorators: [{ type: Optional }, { type: Host }] },
    { type: SourceRasterComponent, decorators: [{ type: Optional }, { type: Host }] }
];
SourceXYZComponent.propDecorators = {
    cacheSize: [{ type: Input }],
    crossOrigin: [{ type: Input }],
    opaque: [{ type: Input }],
    projection: [{ type: Input }],
    reprojectionErrorThreshold: [{ type: Input }],
    minZoom: [{ type: Input }],
    maxZoom: [{ type: Input }],
    tileGrid: [{ type: Input }],
    tileLoadFunction: [{ type: Input }],
    tilePixelRatio: [{ type: Input }],
    tileSize: [{ type: Input }],
    tileUrlFunction: [{ type: Input }],
    url: [{ type: Input }],
    urls: [{ type: Input }],
    wrapX: [{ type: Input }],
    tileGridXYZ: [{ type: ContentChild, args: [TileGridComponent, { static: false },] }],
    tileLoadStart: [{ type: Output }],
    tileLoadEnd: [{ type: Output }],
    tileLoadError: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SourceXYZComponent.prototype.instance;
    /** @type {?} */
    SourceXYZComponent.prototype.cacheSize;
    /** @type {?} */
    SourceXYZComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceXYZComponent.prototype.opaque;
    /** @type {?} */
    SourceXYZComponent.prototype.projection;
    /** @type {?} */
    SourceXYZComponent.prototype.reprojectionErrorThreshold;
    /** @type {?} */
    SourceXYZComponent.prototype.minZoom;
    /** @type {?} */
    SourceXYZComponent.prototype.maxZoom;
    /** @type {?} */
    SourceXYZComponent.prototype.tileGrid;
    /** @type {?} */
    SourceXYZComponent.prototype.tileLoadFunction;
    /** @type {?} */
    SourceXYZComponent.prototype.tilePixelRatio;
    /** @type {?} */
    SourceXYZComponent.prototype.tileSize;
    /** @type {?} */
    SourceXYZComponent.prototype.tileUrlFunction;
    /** @type {?} */
    SourceXYZComponent.prototype.url;
    /** @type {?} */
    SourceXYZComponent.prototype.urls;
    /** @type {?} */
    SourceXYZComponent.prototype.wrapX;
    /** @type {?} */
    SourceXYZComponent.prototype.tileGridXYZ;
    /** @type {?} */
    SourceXYZComponent.prototype.tileLoadStart;
    /** @type {?} */
    SourceXYZComponent.prototype.tileLoadEnd;
    /** @type {?} */
    SourceXYZComponent.prototype.tileLoadError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceOsmComponent extends SourceXYZComponent {
    /**
     * @param {?} layer
     * @param {?=} raster
     */
    constructor(layer, raster) {
        super(layer, raster);
        this.tileLoadStart = new EventEmitter();
        this.tileLoadEnd = new EventEmitter();
        this.tileLoadError = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.tileGridXYZ) {
            this.tileGrid = this.tileGridXYZ.instance;
        }
        this.instance = new OSM(this);
        this.instance.on('tileloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.tileLoadStart.emit(event)));
        this.instance.on('tileloadend', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.tileLoadEnd.emit(event)));
        this.instance.on('tileloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.tileLoadError.emit(event)));
        this._register(this.instance);
    }
}
SourceOsmComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-osm',
                template: `
    <div class="aol-source-osm"></div>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceOsmComponent)) }]
            }] }
];
/** @nocollapse */
SourceOsmComponent.ctorParameters = () => [
    { type: LayerTileComponent, decorators: [{ type: Host }, { type: Optional }] },
    { type: SourceRasterComponent, decorators: [{ type: Host }, { type: Optional }] }
];
SourceOsmComponent.propDecorators = {
    attributions: [{ type: Input }],
    cacheSize: [{ type: Input }],
    crossOrigin: [{ type: Input }],
    maxZoom: [{ type: Input }],
    opaque: [{ type: Input }],
    reprojectionErrorThreshold: [{ type: Input }],
    tileLoadFunction: [{ type: Input }],
    url: [{ type: Input }],
    wrapX: [{ type: Input }],
    tileLoadStart: [{ type: Output }],
    tileLoadEnd: [{ type: Output }],
    tileLoadError: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SourceOsmComponent.prototype.instance;
    /** @type {?} */
    SourceOsmComponent.prototype.attributions;
    /** @type {?} */
    SourceOsmComponent.prototype.cacheSize;
    /** @type {?} */
    SourceOsmComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceOsmComponent.prototype.maxZoom;
    /** @type {?} */
    SourceOsmComponent.prototype.opaque;
    /** @type {?} */
    SourceOsmComponent.prototype.reprojectionErrorThreshold;
    /** @type {?} */
    SourceOsmComponent.prototype.tileLoadFunction;
    /** @type {?} */
    SourceOsmComponent.prototype.url;
    /** @type {?} */
    SourceOsmComponent.prototype.wrapX;
    /** @type {?} */
    SourceOsmComponent.prototype.tileLoadStart;
    /** @type {?} */
    SourceOsmComponent.prototype.tileLoadEnd;
    /** @type {?} */
    SourceOsmComponent.prototype.tileLoadError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceBingmapsComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
        this.imagerySet = 'Aerial';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new BingMaps(this);
        this.host.instance.setSource(this.instance);
    }
}
SourceBingmapsComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-bingmaps',
                template: `
    <div class="aol-source-bingmaps"></div>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceBingmapsComponent)) }]
            }] }
];
/** @nocollapse */
SourceBingmapsComponent.ctorParameters = () => [
    { type: LayerTileComponent, decorators: [{ type: Host }] }
];
SourceBingmapsComponent.propDecorators = {
    cacheSize: [{ type: Input }],
    hidpi: [{ type: Input }],
    culture: [{ type: Input }],
    key: [{ type: Input }],
    imagerySet: [{ type: Input }],
    maxZoom: [{ type: Input }],
    reprojectionErrorThreshold: [{ type: Input }],
    tileLoadFunction: [{ type: Input }],
    wrapX: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    SourceBingmapsComponent.prototype.instance;
    /** @type {?} */
    SourceBingmapsComponent.prototype.cacheSize;
    /** @type {?} */
    SourceBingmapsComponent.prototype.hidpi;
    /** @type {?} */
    SourceBingmapsComponent.prototype.culture;
    /** @type {?} */
    SourceBingmapsComponent.prototype.key;
    /** @type {?} */
    SourceBingmapsComponent.prototype.imagerySet;
    /** @type {?} */
    SourceBingmapsComponent.prototype.maxZoom;
    /** @type {?} */
    SourceBingmapsComponent.prototype.reprojectionErrorThreshold;
    /** @type {?} */
    SourceBingmapsComponent.prototype.tileLoadFunction;
    /** @type {?} */
    SourceBingmapsComponent.prototype.wrapX;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceVectorComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new Vector$1(this);
        this.host.instance.setSource(this.instance);
    }
}
SourceVectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-vector',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceVectorComponent)) }]
            }] }
];
/** @nocollapse */
SourceVectorComponent.ctorParameters = () => [
    { type: LayerVectorComponent, decorators: [{ type: Host }] }
];
SourceVectorComponent.propDecorators = {
    overlaps: [{ type: Input }],
    useSpatialIndex: [{ type: Input }],
    wrapX: [{ type: Input }],
    url: [{ type: Input }],
    format: [{ type: Input }],
    strategy: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    SourceVectorComponent.prototype.instance;
    /** @type {?} */
    SourceVectorComponent.prototype.overlaps;
    /** @type {?} */
    SourceVectorComponent.prototype.useSpatialIndex;
    /** @type {?} */
    SourceVectorComponent.prototype.wrapX;
    /** @type {?} */
    SourceVectorComponent.prototype.url;
    /** @type {?} */
    SourceVectorComponent.prototype.format;
    /** @type {?} */
    SourceVectorComponent.prototype.strategy;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceClusterComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.source = this.sourceVectorComponent.instance;
        this.instance = new Cluster(this);
        this.host.instance.setSource(this.instance);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.instance && changes.hasOwnProperty('distance')) {
            this.instance.setDistance(this.distance);
        }
    }
}
SourceClusterComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-cluster',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceClusterComponent)) }]
            }] }
];
/** @nocollapse */
SourceClusterComponent.ctorParameters = () => [
    { type: LayerVectorComponent, decorators: [{ type: Host }] }
];
SourceClusterComponent.propDecorators = {
    distance: [{ type: Input }],
    geometryFunction: [{ type: Input }],
    wrapX: [{ type: Input }],
    sourceVectorComponent: [{ type: ContentChild, args: [SourceVectorComponent, { static: false },] }]
};
if (false) {
    /** @type {?} */
    SourceClusterComponent.prototype.instance;
    /** @type {?} */
    SourceClusterComponent.prototype.distance;
    /** @type {?} */
    SourceClusterComponent.prototype.geometryFunction;
    /** @type {?} */
    SourceClusterComponent.prototype.wrapX;
    /** @type {?} */
    SourceClusterComponent.prototype.sourceVectorComponent;
    /** @type {?} */
    SourceClusterComponent.prototype.source;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TileGridWMTSComponent extends TileGridComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new WMTS(this);
    }
}
TileGridWMTSComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-tilegrid-wmts',
                template: ''
            }] }
];
TileGridWMTSComponent.propDecorators = {
    origin: [{ type: Input }],
    origins: [{ type: Input }],
    resolutions: [{ type: Input }],
    matrixIds: [{ type: Input }],
    sizes: [{ type: Input }],
    tileSizes: [{ type: Input }],
    widths: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TileGridWMTSComponent.prototype.instance;
    /** @type {?} */
    TileGridWMTSComponent.prototype.origin;
    /** @type {?} */
    TileGridWMTSComponent.prototype.origins;
    /** @type {?} */
    TileGridWMTSComponent.prototype.resolutions;
    /** @type {?} */
    TileGridWMTSComponent.prototype.matrixIds;
    /** @type {?} */
    TileGridWMTSComponent.prototype.sizes;
    /** @type {?} */
    TileGridWMTSComponent.prototype.tileSizes;
    /** @type {?} */
    TileGridWMTSComponent.prototype.widths;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceTileWMTSComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
        this.tileLoadStart = new EventEmitter();
        this.tileLoadEnd = new EventEmitter();
        this.tileLoadError = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const properties = {};
        if (!this.instance) {
            return;
        }
        for (const key in changes) {
            if (changes.hasOwnProperty(key)) {
                switch (key) {
                    case 'url':
                        this.url = changes[key].currentValue;
                        this.setLayerSource();
                        break;
                    default:
                        break;
                }
                properties[key] = changes[key].currentValue;
            }
        }
        this.instance.setProperties(properties, false);
    }
    /**
     * @return {?}
     */
    setLayerSource() {
        this.instance = new WMTS$1(this);
        this.instance.on('tileloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.tileLoadStart.emit(event)));
        this.instance.on('tileloadend', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.tileLoadEnd.emit(event)));
        this.instance.on('tileloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.tileLoadError.emit(event)));
        this.host.instance.setSource(this.instance);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.tileGridWMTS) {
            this.tileGrid = this.tileGridWMTS.instance;
            this.setLayerSource();
        }
    }
}
SourceTileWMTSComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-tilewmts',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceTileWMTSComponent)) }]
            }] }
];
/** @nocollapse */
SourceTileWMTSComponent.ctorParameters = () => [
    { type: LayerTileComponent, decorators: [{ type: Host }] }
];
SourceTileWMTSComponent.propDecorators = {
    cacheSize: [{ type: Input }],
    crossOrigin: [{ type: Input }],
    tileGrid: [{ type: Input }],
    projection: [{ type: Input }],
    reprojectionErrorThreshold: [{ type: Input }],
    requestEncoding: [{ type: Input }],
    layer: [{ type: Input }],
    style: [{ type: Input }],
    tileClass: [{ type: Input }],
    tilePixelRatio: [{ type: Input }],
    version: [{ type: Input }],
    format: [{ type: Input }],
    matrixSet: [{ type: Input }],
    dimensions: [{ type: Input }],
    url: [{ type: Input }],
    tileLoadFunction: [{ type: Input }],
    urls: [{ type: Input }],
    wrapX: [{ type: Input }],
    tileLoadStart: [{ type: Output }],
    tileLoadEnd: [{ type: Output }],
    tileLoadError: [{ type: Output }],
    tileGridWMTS: [{ type: ContentChild, args: [TileGridWMTSComponent, { static: false },] }]
};
if (false) {
    /** @type {?} */
    SourceTileWMTSComponent.prototype.instance;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.cacheSize;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileGrid;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.projection;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.reprojectionErrorThreshold;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.requestEncoding;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.layer;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.style;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileClass;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tilePixelRatio;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.version;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.format;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.matrixSet;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.dimensions;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.url;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileLoadFunction;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.urls;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.wrapX;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileLoadStart;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileLoadEnd;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileLoadError;
    /** @type {?} */
    SourceTileWMTSComponent.prototype.tileGridWMTS;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormatComponent {
    constructor() {
        this.componentType = 'format';
    }
}
if (false) {
    /** @type {?} */
    FormatComponent.prototype.instance;
    /** @type {?} */
    FormatComponent.prototype.componentType;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceVectorTileComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
    }
    /* need the children to construct the OL3 object */
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.format = this.formatComponent.instance;
        this.tileGrid = this.tileGridComponent.instance;
        // console.log('creating ol.source.VectorTile instance with:', this);
        this.instance = new VectorTile$1(this);
        this.host.instance.setSource(this.instance);
    }
}
SourceVectorTileComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-vectortile',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceVectorTileComponent)) }]
            }] }
];
/** @nocollapse */
SourceVectorTileComponent.ctorParameters = () => [
    { type: LayerVectorTileComponent, decorators: [{ type: Host }] }
];
SourceVectorTileComponent.propDecorators = {
    cacheSize: [{ type: Input }],
    overlaps: [{ type: Input }],
    projection: [{ type: Input }],
    tilePixelRatio: [{ type: Input }],
    tileUrlFunction: [{ type: Input }],
    url: [{ type: Input }],
    urls: [{ type: Input }],
    wrapX: [{ type: Input }],
    formatComponent: [{ type: ContentChild, args: [FormatComponent, { static: false },] }],
    tileGridComponent: [{ type: ContentChild, args: [TileGridComponent, { static: false },] }]
};
if (false) {
    /** @type {?} */
    SourceVectorTileComponent.prototype.instance;
    /** @type {?} */
    SourceVectorTileComponent.prototype.cacheSize;
    /** @type {?} */
    SourceVectorTileComponent.prototype.overlaps;
    /** @type {?} */
    SourceVectorTileComponent.prototype.projection;
    /** @type {?} */
    SourceVectorTileComponent.prototype.tilePixelRatio;
    /** @type {?} */
    SourceVectorTileComponent.prototype.tileUrlFunction;
    /** @type {?} */
    SourceVectorTileComponent.prototype.url;
    /** @type {?} */
    SourceVectorTileComponent.prototype.urls;
    /** @type {?} */
    SourceVectorTileComponent.prototype.wrapX;
    /** @type {?} */
    SourceVectorTileComponent.prototype.formatComponent;
    /** @type {?} */
    SourceVectorTileComponent.prototype.format;
    /** @type {?} */
    SourceVectorTileComponent.prototype.tileGridComponent;
    /** @type {?} */
    SourceVectorTileComponent.prototype.tileGrid;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceTileWMSComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new TileWMS(this);
        this.host.instance.setSource(this.instance);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.instance && changes.hasOwnProperty('params')) {
            this.instance.updateParams(this.params);
        }
    }
}
SourceTileWMSComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-tilewms',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceTileWMSComponent)) }]
            }] }
];
/** @nocollapse */
SourceTileWMSComponent.ctorParameters = () => [
    { type: LayerTileComponent, decorators: [{ type: Host }] }
];
SourceTileWMSComponent.propDecorators = {
    cacheSize: [{ type: Input }],
    crossOrigin: [{ type: Input }],
    gutter: [{ type: Input }],
    hidpi: [{ type: Input }],
    params: [{ type: Input }],
    projection: [{ type: Input }],
    reprojectionErrorThreshold: [{ type: Input }],
    serverType: [{ type: Input }],
    tileGrid: [{ type: Input }],
    tileLoadFunction: [{ type: Input }],
    url: [{ type: Input }],
    urls: [{ type: Input }],
    wrapX: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    SourceTileWMSComponent.prototype.instance;
    /** @type {?} */
    SourceTileWMSComponent.prototype.cacheSize;
    /** @type {?} */
    SourceTileWMSComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceTileWMSComponent.prototype.gutter;
    /** @type {?} */
    SourceTileWMSComponent.prototype.hidpi;
    /** @type {?} */
    SourceTileWMSComponent.prototype.params;
    /** @type {?} */
    SourceTileWMSComponent.prototype.projection;
    /** @type {?} */
    SourceTileWMSComponent.prototype.reprojectionErrorThreshold;
    /** @type {?} */
    SourceTileWMSComponent.prototype.serverType;
    /** @type {?} */
    SourceTileWMSComponent.prototype.tileGrid;
    /** @type {?} */
    SourceTileWMSComponent.prototype.tileLoadFunction;
    /** @type {?} */
    SourceTileWMSComponent.prototype.url;
    /** @type {?} */
    SourceTileWMSComponent.prototype.urls;
    /** @type {?} */
    SourceTileWMSComponent.prototype.wrapX;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceTileJSONComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new TileJSON(this);
        this.host.instance.setSource(this.instance);
    }
}
SourceTileJSONComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-tilejson',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceTileJSONComponent)) }]
            }] }
];
/** @nocollapse */
SourceTileJSONComponent.ctorParameters = () => [
    { type: LayerTileComponent, decorators: [{ type: Host }] }
];
SourceTileJSONComponent.propDecorators = {
    url: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    SourceTileJSONComponent.prototype.instance;
    /** @type {?} */
    SourceTileJSONComponent.prototype.url;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceGeoJSONComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.format = new GeoJSON(this);
        this.instance = new Vector$1(this);
        this.host.instance.setSource(this.instance);
    }
}
SourceGeoJSONComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-geojson',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceGeoJSONComponent)) }]
            }] }
];
/** @nocollapse */
SourceGeoJSONComponent.ctorParameters = () => [
    { type: LayerVectorComponent, decorators: [{ type: Host }] }
];
SourceGeoJSONComponent.propDecorators = {
    defaultDataProjection: [{ type: Input }],
    featureProjection: [{ type: Input }],
    geometryName: [{ type: Input }],
    url: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    SourceGeoJSONComponent.prototype.instance;
    /** @type {?} */
    SourceGeoJSONComponent.prototype.format;
    /** @type {?} */
    SourceGeoJSONComponent.prototype.defaultDataProjection;
    /** @type {?} */
    SourceGeoJSONComponent.prototype.featureProjection;
    /** @type {?} */
    SourceGeoJSONComponent.prototype.geometryName;
    /** @type {?} */
    SourceGeoJSONComponent.prototype.url;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceImageStaticComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
        this.imageLoadStart = new EventEmitter();
        this.imageLoadEnd = new EventEmitter();
        this.imageLoadError = new EventEmitter();
    }
    /**
     * @return {?}
     */
    setLayerSource() {
        this.instance = new ImageStatic(this);
        this.host.instance.setSource(this.instance);
        this.instance.on('imageloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.imageLoadStart.emit(event)));
        this.instance.on('imageloadend', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.imageLoadEnd.emit(event)));
        this.instance.on('imageloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.imageLoadError.emit(event)));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setLayerSource();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const properties = {};
        if (!this.instance) {
            return;
        }
        for (const key in changes) {
            if (changes.hasOwnProperty(key)) {
                switch (key) {
                    case 'url':
                        this.url = changes[key].currentValue;
                        this.setLayerSource();
                        break;
                    default:
                        break;
                }
                properties[key] = changes[key].currentValue;
            }
        }
        this.instance.setProperties(properties, false);
    }
}
SourceImageStaticComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-imagestatic',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceImageStaticComponent)) }]
            }] }
];
/** @nocollapse */
SourceImageStaticComponent.ctorParameters = () => [
    { type: LayerImageComponent, decorators: [{ type: Host }] }
];
SourceImageStaticComponent.propDecorators = {
    projection: [{ type: Input }],
    imageExtent: [{ type: Input }],
    url: [{ type: Input }],
    attributions: [{ type: Input }],
    crossOrigin: [{ type: Input }],
    imageLoadFunction: [{ type: Input }],
    imageSize: [{ type: Input }],
    imageLoadStart: [{ type: Output }],
    imageLoadEnd: [{ type: Output }],
    imageLoadError: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SourceImageStaticComponent.prototype.instance;
    /** @type {?} */
    SourceImageStaticComponent.prototype.projection;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageExtent;
    /** @type {?} */
    SourceImageStaticComponent.prototype.url;
    /** @type {?} */
    SourceImageStaticComponent.prototype.attributions;
    /** @type {?} */
    SourceImageStaticComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageLoadFunction;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageSize;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageLoadStart;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageLoadEnd;
    /** @type {?} */
    SourceImageStaticComponent.prototype.imageLoadError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceImageWMSComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
        this.imageLoadStart = new EventEmitter();
        this.imageLoadEnd = new EventEmitter();
        this.imageLoadError = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new ImageWMS(this);
        this.host.instance.setSource(this.instance);
        this.instance.on('imageloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.imageLoadStart.emit(event)));
        this.instance.on('imageloadend', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.imageLoadEnd.emit(event)));
        this.instance.on('imageloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.imageLoadError.emit(event)));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.instance && changes.hasOwnProperty('params')) {
            this.instance.updateParams(this.params);
        }
    }
}
SourceImageWMSComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-imagewms',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceImageWMSComponent)) }]
            }] }
];
/** @nocollapse */
SourceImageWMSComponent.ctorParameters = () => [
    { type: LayerImageComponent, decorators: [{ type: Host }] }
];
SourceImageWMSComponent.propDecorators = {
    attributions: [{ type: Input }],
    crossOrigin: [{ type: Input }],
    hidpi: [{ type: Input }],
    serverType: [{ type: Input }],
    imageLoadFunction: [{ type: Input }],
    params: [{ type: Input }],
    projection: [{ type: Input }],
    ratio: [{ type: Input }],
    resolutions: [{ type: Input }],
    url: [{ type: Input }],
    imageLoadStart: [{ type: Output }],
    imageLoadEnd: [{ type: Output }],
    imageLoadError: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SourceImageWMSComponent.prototype.instance;
    /** @type {?} */
    SourceImageWMSComponent.prototype.attributions;
    /** @type {?} */
    SourceImageWMSComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceImageWMSComponent.prototype.hidpi;
    /** @type {?} */
    SourceImageWMSComponent.prototype.serverType;
    /** @type {?} */
    SourceImageWMSComponent.prototype.imageLoadFunction;
    /** @type {?} */
    SourceImageWMSComponent.prototype.params;
    /** @type {?} */
    SourceImageWMSComponent.prototype.projection;
    /** @type {?} */
    SourceImageWMSComponent.prototype.ratio;
    /** @type {?} */
    SourceImageWMSComponent.prototype.resolutions;
    /** @type {?} */
    SourceImageWMSComponent.prototype.url;
    /** @type {?} */
    SourceImageWMSComponent.prototype.imageLoadStart;
    /** @type {?} */
    SourceImageWMSComponent.prototype.imageLoadEnd;
    /** @type {?} */
    SourceImageWMSComponent.prototype.imageLoadError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceImageArcGISRestComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
        this.ratio = 1.5;
        this.imageLoadStart = new EventEmitter();
        this.imageLoadEnd = new EventEmitter();
        this.imageLoadError = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new ImageArcGISRest(this);
        this.host.instance.setSource(this.instance);
        this.instance.on('imageloadstart', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.imageLoadStart.emit(event)));
        this.instance.on('imageloadend', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.imageLoadEnd.emit(event)));
        this.instance.on('imageloaderror', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.imageLoadError.emit(event)));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.instance && changes.hasOwnProperty('params')) {
            this.instance.updateParams(this.params);
        }
    }
}
SourceImageArcGISRestComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-imagearcgisrest',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceImageArcGISRestComponent)) }]
            }] }
];
/** @nocollapse */
SourceImageArcGISRestComponent.ctorParameters = () => [
    { type: LayerImageComponent, decorators: [{ type: Host }] }
];
SourceImageArcGISRestComponent.propDecorators = {
    projection: [{ type: Input }],
    url: [{ type: Input }],
    attributions: [{ type: Input }],
    crossOrigin: [{ type: Input }],
    imageLoadFunction: [{ type: Input }],
    params: [{ type: Input }],
    ratio: [{ type: Input }],
    resolutions: [{ type: Input }],
    wrapX: [{ type: Input }],
    imageLoadStart: [{ type: Output }],
    imageLoadEnd: [{ type: Output }],
    imageLoadError: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.instance;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.projection;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.url;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.attributions;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.crossOrigin;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.imageLoadFunction;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.params;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.ratio;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.resolutions;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.wrapX;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.imageLoadStart;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.imageLoadEnd;
    /** @type {?} */
    SourceImageArcGISRestComponent.prototype.imageLoadError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FeatureComponent {
    /**
     * @param {?} host
     */
    constructor(host) {
        this.host = host;
        this.componentType = 'feature';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new Feature();
        if (this.id !== undefined) {
            this.instance.setId(this.id);
        }
        this.host.instance.addFeature(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.host.instance.removeFeature(this.instance);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.instance) {
            this.instance.setId(this.id);
        }
    }
}
FeatureComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-feature',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
FeatureComponent.ctorParameters = () => [
    { type: SourceVectorComponent }
];
FeatureComponent.propDecorators = {
    id: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FeatureComponent.prototype.componentType;
    /** @type {?} */
    FeatureComponent.prototype.instance;
    /** @type {?} */
    FeatureComponent.prototype.id;
    /**
     * @type {?}
     * @private
     */
    FeatureComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class SimpleGeometryComponent {
    /**
     * @param {?} map
     * @param {?} host
     */
    constructor(map, host) {
        this.map = map;
        this.host = host;
        this.componentType = 'simple-geometry';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.host.instance.setGeometry(this.instance);
    }
}
SimpleGeometryComponent.propDecorators = {
    srid: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    SimpleGeometryComponent.prototype.instance;
    /** @type {?} */
    SimpleGeometryComponent.prototype.componentType;
    /** @type {?} */
    SimpleGeometryComponent.prototype.srid;
    /**
     * @type {?}
     * @protected
     */
    SimpleGeometryComponent.prototype.map;
    /**
     * @type {?}
     * @protected
     */
    SimpleGeometryComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeometryCircleComponent extends SimpleGeometryComponent {
    /**
     * @param {?} map
     * @param {?} host
     */
    constructor(map, host) {
        super(map, host);
        this.componentType = 'geometry-circle';
        // defaulting coordinates to [0,0]. To be overridden in child component.
        this.instance = new Circle([0, 0]);
    }
    /**
     * @return {?}
     */
    get radius() {
        return this.instance.getRadius();
    }
    /**
     * @param {?} radius
     * @return {?}
     */
    set radius(radius) {
        this.instance.setRadius(radius);
    }
}
GeometryCircleComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-geometry-circle',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
GeometryCircleComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: FeatureComponent }
];
GeometryCircleComponent.propDecorators = {
    radius: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    GeometryCircleComponent.prototype.componentType;
    /** @type {?} */
    GeometryCircleComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeometryLinestringComponent extends SimpleGeometryComponent {
    /**
     * @param {?} map
     * @param {?} host
     */
    constructor(map, host) {
        super(map, host);
        this.componentType = 'geometry-linestring';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new LineString([[0, 0], [1, 1]]);
        super.ngOnInit();
    }
}
GeometryLinestringComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-geometry-linestring',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
GeometryLinestringComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: FeatureComponent }
];
if (false) {
    /** @type {?} */
    GeometryLinestringComponent.prototype.componentType;
    /** @type {?} */
    GeometryLinestringComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeometryMultiLinestringComponent extends SimpleGeometryComponent {
    /**
     * @param {?} map
     * @param {?} host
     */
    constructor(map, host) {
        super(map, host);
        this.componentType = 'geometry-multilinestring';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new MultiLineString([[[0, 0], [1, 1]]]);
        super.ngOnInit();
    }
}
GeometryMultiLinestringComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-geometry-multilinestring',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
GeometryMultiLinestringComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: FeatureComponent }
];
if (false) {
    /** @type {?} */
    GeometryMultiLinestringComponent.prototype.componentType;
    /** @type {?} */
    GeometryMultiLinestringComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeometryMultiPointComponent extends SimpleGeometryComponent {
    /**
     * @param {?} map
     * @param {?} host
     */
    constructor(map, host) {
        super(map, host);
        this.componentType = 'geometry-multipoint';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new MultiPoint([[0, 0], [1, 1]]);
        super.ngOnInit();
    }
}
GeometryMultiPointComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-geometry-multipoint',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
GeometryMultiPointComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: FeatureComponent }
];
if (false) {
    /** @type {?} */
    GeometryMultiPointComponent.prototype.componentType;
    /** @type {?} */
    GeometryMultiPointComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeometryMultiPolygonComponent extends SimpleGeometryComponent {
    /**
     * @param {?} map
     * @param {?} host
     */
    constructor(map, host) {
        super(map, host);
        this.componentType = 'geometry-multipolygon';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new MultiPolygon([[[[0, 0], [1, 1], [0, 1]]]]);
        super.ngOnInit();
    }
}
GeometryMultiPolygonComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-geometry-multipolygon',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
GeometryMultiPolygonComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: FeatureComponent }
];
if (false) {
    /** @type {?} */
    GeometryMultiPolygonComponent.prototype.componentType;
    /** @type {?} */
    GeometryMultiPolygonComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeometryPointComponent extends SimpleGeometryComponent {
    /**
     * @param {?} map
     * @param {?} host
     */
    constructor(map, host) {
        super(map, host);
        this.componentType = 'geometry-point';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new Point([0, 0]);
        super.ngOnInit();
    }
}
GeometryPointComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-geometry-point',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
GeometryPointComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: FeatureComponent }
];
if (false) {
    /** @type {?} */
    GeometryPointComponent.prototype.componentType;
    /** @type {?} */
    GeometryPointComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeometryPolygonComponent extends SimpleGeometryComponent {
    /**
     * @param {?} map
     * @param {?} host
     */
    constructor(map, host) {
        super(map, host);
        this.componentType = 'geometry-polygon';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new Polygon([[[0, 0], [1, 1], [0, 1]]]);
        super.ngOnInit();
    }
}
GeometryPolygonComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-geometry-polygon',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
GeometryPolygonComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: FeatureComponent }
];
if (false) {
    /** @type {?} */
    GeometryPolygonComponent.prototype.componentType;
    /** @type {?} */
    GeometryPolygonComponent.prototype.instance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
ContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-content',
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
ContentComponent.ctorParameters = () => [
    { type: ElementRef }
];
if (false) {
    /** @type {?} */
    ContentComponent.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OverlayComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        this.componentType = 'overlay';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.content) {
            this.element = this.content.elementRef.nativeElement;
            this.instance = new Overlay(this);
            this.map.instance.addOverlay(this.instance);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.instance) {
            this.map.instance.removeOverlay(this.instance);
        }
    }
}
OverlayComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-overlay',
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
OverlayComponent.ctorParameters = () => [
    { type: MapComponent }
];
OverlayComponent.propDecorators = {
    content: [{ type: ContentChild, args: [ContentComponent, { static: true },] }],
    id: [{ type: Input }],
    offset: [{ type: Input }],
    positioning: [{ type: Input }],
    stopEvent: [{ type: Input }],
    insertFirst: [{ type: Input }],
    autoPan: [{ type: Input }],
    autoPanAnimation: [{ type: Input }],
    autoPanMargin: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    OverlayComponent.prototype.componentType;
    /** @type {?} */
    OverlayComponent.prototype.instance;
    /** @type {?} */
    OverlayComponent.prototype.element;
    /** @type {?} */
    OverlayComponent.prototype.content;
    /** @type {?} */
    OverlayComponent.prototype.id;
    /** @type {?} */
    OverlayComponent.prototype.offset;
    /** @type {?} */
    OverlayComponent.prototype.positioning;
    /** @type {?} */
    OverlayComponent.prototype.stopEvent;
    /** @type {?} */
    OverlayComponent.prototype.insertFirst;
    /** @type {?} */
    OverlayComponent.prototype.autoPan;
    /** @type {?} */
    OverlayComponent.prototype.autoPanAnimation;
    /** @type {?} */
    OverlayComponent.prototype.autoPanMargin;
    /**
     * @type {?}
     * @private
     */
    OverlayComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CoordinateComponent {
    /**
     * @param {?} map
     * @param {?} viewHost
     * @param {?} geometryPointHost
     * @param {?} geometryCircleHost
     * @param {?} overlayHost
     */
    constructor(map, viewHost, geometryPointHost, geometryCircleHost, overlayHost) {
        this.map = map;
        this.mapSrid = 'EPSG:3857';
        this.srid = 'EPSG:3857';
        // console.log('instancing aol-coordinate');
        if (geometryPointHost !== null) {
            this.host = geometryPointHost;
        }
        else if (geometryCircleHost !== null) {
            this.host = geometryCircleHost;
        }
        else if (viewHost !== null) {
            this.host = viewHost;
        }
        else if (overlayHost !== null) {
            this.host = overlayHost;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.map.instance.on('change:view', (/**
         * @param {?} e
         * @return {?}
         */
        e => this.onMapViewChanged(e)));
        this.mapSrid = this.map.instance
            .getView()
            .getProjection()
            .getCode();
        this.transformCoordinates();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.transformCoordinates();
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onMapViewChanged(event) {
        this.mapSrid = event.target
            .get(event.key)
            .getProjection()
            .getCode();
        this.transformCoordinates();
    }
    /**
     * @private
     * @return {?}
     */
    transformCoordinates() {
        /** @type {?} */
        let transformedCoordinates;
        if (this.srid === this.mapSrid) {
            transformedCoordinates = [this.x, this.y];
        }
        else {
            transformedCoordinates = transform([this.x, this.y], this.srid, this.mapSrid);
        }
        switch (this.host.componentType) {
            case 'geometry-point':
                this.host.instance.setCoordinates(transformedCoordinates);
                break;
            case 'geometry-circle':
            case 'view':
                this.host.instance.setCenter(transformedCoordinates);
                break;
            case 'overlay':
                this.host.instance.setPosition(transformedCoordinates);
                break;
        }
    }
}
CoordinateComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-coordinate',
                template: `
    <div class="aol-coordinate"></div>
  `
            }] }
];
/** @nocollapse */
CoordinateComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: ViewComponent, decorators: [{ type: Optional }] },
    { type: GeometryPointComponent, decorators: [{ type: Optional }] },
    { type: GeometryCircleComponent, decorators: [{ type: Optional }] },
    { type: OverlayComponent, decorators: [{ type: Optional }] }
];
CoordinateComponent.propDecorators = {
    x: [{ type: Input }],
    y: [{ type: Input }],
    srid: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    CoordinateComponent.prototype.host;
    /**
     * @type {?}
     * @private
     */
    CoordinateComponent.prototype.mapSrid;
    /** @type {?} */
    CoordinateComponent.prototype.x;
    /** @type {?} */
    CoordinateComponent.prototype.y;
    /** @type {?} */
    CoordinateComponent.prototype.srid;
    /**
     * @type {?}
     * @private
     */
    CoordinateComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CollectionCoordinatesComponent {
    /**
     * @param {?} map
     * @param {?} geometryLinestring
     * @param {?} geometryPolygon
     * @param {?} geometryMultipoint
     * @param {?} geometryMultilinestring
     * @param {?} geometryMultipolygon
     */
    constructor(map, geometryLinestring, geometryPolygon, geometryMultipoint, geometryMultilinestring, geometryMultipolygon) {
        this.map = map;
        this.mapSrid = 'EPSG:3857';
        this.srid = 'EPSG:3857';
        if (!!geometryLinestring) {
            this.host = geometryLinestring;
        }
        else if (!!geometryPolygon) {
            this.host = geometryPolygon;
        }
        else if (!!geometryMultipoint) {
            this.host = geometryMultipoint;
        }
        else if (!!geometryMultilinestring) {
            this.host = geometryMultilinestring;
        }
        else if (!!geometryMultipolygon) {
            this.host = geometryMultipolygon;
        }
        else {
            throw new Error('aol-collection-coordinates must be a child of a geometry component');
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.map.instance.on('change:view', (/**
         * @param {?} e
         * @return {?}
         */
        e => this.onMapViewChanged(e)));
        this.mapSrid = this.map.instance
            .getView()
            .getProjection()
            .getCode();
        this.transformCoordinates();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.transformCoordinates();
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onMapViewChanged(event) {
        this.mapSrid = event.target
            .get(event.key)
            .getProjection()
            .getCode();
        this.transformCoordinates();
    }
    /**
     * @private
     * @return {?}
     */
    transformCoordinates() {
        /** @type {?} */
        let transformedCoordinates;
        if (this.srid === this.mapSrid) {
            transformedCoordinates = this.coordinates;
        }
        else {
            switch (this.host.componentType) {
                case 'geometry-linestring':
                case 'geometry-multipoint':
                    transformedCoordinates = ((/** @type {?} */ (this.coordinates))).map((/**
                     * @param {?} c
                     * @return {?}
                     */
                    c => transform(c, this.srid, this.mapSrid)));
                    break;
                case 'geometry-polygon':
                case 'geometry-multilinestring':
                    transformedCoordinates = ((/** @type {?} */ (this.coordinates))).map((/**
                     * @param {?} cc
                     * @return {?}
                     */
                    cc => cc.map((/**
                     * @param {?} c
                     * @return {?}
                     */
                    c => transform(c, this.srid, this.mapSrid)))));
                    break;
                case 'geometry-multipolygon':
                    transformedCoordinates = ((/** @type {?} */ (this.coordinates))).map((/**
                     * @param {?} ccc
                     * @return {?}
                     */
                    ccc => ccc.map((/**
                     * @param {?} cc
                     * @return {?}
                     */
                    cc => cc.map((/**
                     * @param {?} c
                     * @return {?}
                     */
                    c => transform(c, this.srid, this.mapSrid)))))));
                    break;
            }
        }
        this.host.instance.setCoordinates(transformedCoordinates);
    }
}
CollectionCoordinatesComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-collection-coordinates',
                template: `
    <div class="aol-collection-coordinates"></div>
  `
            }] }
];
/** @nocollapse */
CollectionCoordinatesComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: GeometryLinestringComponent, decorators: [{ type: Optional }] },
    { type: GeometryPolygonComponent, decorators: [{ type: Optional }] },
    { type: GeometryMultiPointComponent, decorators: [{ type: Optional }] },
    { type: GeometryMultiLinestringComponent, decorators: [{ type: Optional }] },
    { type: GeometryMultiPolygonComponent, decorators: [{ type: Optional }] }
];
CollectionCoordinatesComponent.propDecorators = {
    coordinates: [{ type: Input }],
    srid: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    CollectionCoordinatesComponent.prototype.host;
    /**
     * @type {?}
     * @private
     */
    CollectionCoordinatesComponent.prototype.mapSrid;
    /** @type {?} */
    CollectionCoordinatesComponent.prototype.coordinates;
    /** @type {?} */
    CollectionCoordinatesComponent.prototype.srid;
    /**
     * @type {?}
     * @private
     */
    CollectionCoordinatesComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StyleComponent {
    /**
     * @param {?} featureHost
     * @param {?} layerHost
     */
    constructor(featureHost, layerHost) {
        this.componentType = 'style';
        // console.log('creating aol-style');
        this.host = !!featureHost ? featureHost : layerHost;
        if (!this.host) {
            throw new Error('aol-style must be applied to a feature or a layer');
        }
    }
    /**
     * @return {?}
     */
    update() {
        // console.log('updating style\'s host: ', this.host);
        this.host.instance.changed();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('creating aol-style instance with: ', this);
        this.instance = new Style(this);
        this.host.instance.setStyle(this.instance);
    }
}
StyleComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-style',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
StyleComponent.ctorParameters = () => [
    { type: FeatureComponent, decorators: [{ type: Optional }] },
    { type: LayerVectorComponent, decorators: [{ type: Optional }] }
];
StyleComponent.propDecorators = {
    geometry: [{ type: Input }],
    fill: [{ type: Input }],
    image: [{ type: Input }],
    stroke: [{ type: Input }],
    text: [{ type: Input }],
    zIndex: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    StyleComponent.prototype.host;
    /** @type {?} */
    StyleComponent.prototype.instance;
    /** @type {?} */
    StyleComponent.prototype.componentType;
    /** @type {?} */
    StyleComponent.prototype.geometry;
    /** @type {?} */
    StyleComponent.prototype.fill;
    /** @type {?} */
    StyleComponent.prototype.image;
    /** @type {?} */
    StyleComponent.prototype.stroke;
    /** @type {?} */
    StyleComponent.prototype.text;
    /** @type {?} */
    StyleComponent.prototype.zIndex;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StyleCircleComponent {
    /**
     * @param {?} host
     */
    constructor(host) {
        this.host = host;
        this.componentType = 'style-circle';
    }
    /**
     * WORK-AROUND: since the re-rendering is not triggered on style change
     * we trigger a radius change.
     * see openlayers #6233 and #5775
     * @return {?}
     */
    update() {
        if (!!this.instance) {
            // console.log('setting ol.style.Circle instance\'s radius');
            this.instance.setRadius(this.radius);
        }
        this.host.update();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // console.log('creating ol.style.Circle instance with: ', this);
        this.instance = new Circle$1(this);
        this.host.instance.setImage(this.instance);
        this.host.update();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.instance) {
            return;
        }
        if (changes.radius) {
            this.instance.setRadius(changes.radius.currentValue);
        }
        // console.log('changes detected in aol-style-circle, setting new radius: ', changes['radius'].currentValue);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('removing aol-style-circle');
        this.host.instance.setImage(null);
    }
}
StyleCircleComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-style-circle',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
StyleCircleComponent.ctorParameters = () => [
    { type: StyleComponent, decorators: [{ type: Host }] }
];
StyleCircleComponent.propDecorators = {
    fill: [{ type: Input }],
    radius: [{ type: Input }],
    snapToPixel: [{ type: Input }],
    stroke: [{ type: Input }],
    atlasManager: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    StyleCircleComponent.prototype.componentType;
    /** @type {?} */
    StyleCircleComponent.prototype.instance;
    /** @type {?} */
    StyleCircleComponent.prototype.fill;
    /** @type {?} */
    StyleCircleComponent.prototype.radius;
    /** @type {?} */
    StyleCircleComponent.prototype.snapToPixel;
    /** @type {?} */
    StyleCircleComponent.prototype.stroke;
    /** @type {?} */
    StyleCircleComponent.prototype.atlasManager;
    /**
     * @type {?}
     * @private
     */
    StyleCircleComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StyleTextComponent {
    /**
     * @param {?} host
     */
    constructor(host) {
        this.host = host;
        this.componentType = 'style-text';
        if (!host) {
            throw new Error('aol-style-text must be a descendant of aol-style');
        }
        // console.log('creating aol-style-text with: ', this);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('creating ol.style.Text instance with: ', this);
        this.instance = new Text(this);
        this.host.instance.setText(this.instance);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.instance) {
            return;
        }
        if (changes.font) {
            this.instance.setFont(changes.font.currentValue);
        }
        if (changes.offsetX) {
            this.instance.setOffsetX(changes.offsetX.currentValue);
        }
        if (changes.offsetY) {
            this.instance.setOffsetY(changes.offsetY.currentValue);
        }
        if (changes.scale) {
            this.instance.setScale(changes.scale.currentValue);
        }
        if (changes.rotation) {
            this.instance.setRotation(changes.rotation.currentValue);
        }
        if (changes.text) {
            this.instance.setText(changes.text.currentValue);
        }
        if (changes.textAlign) {
            this.instance.setTextAlign(changes.textAlign.currentValue);
        }
        if (changes.textBaseLine) {
            this.instance.setTextBaseline(changes.textBaseLine.currentValue);
        }
        this.host.update();
        // console.log('changes detected in aol-style-text, setting new properties: ', changes);
    }
}
StyleTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-style-text',
                template: `
    <div class="aol-style-text"></div>
  `
            }] }
];
/** @nocollapse */
StyleTextComponent.ctorParameters = () => [
    { type: StyleComponent, decorators: [{ type: Optional }] }
];
StyleTextComponent.propDecorators = {
    font: [{ type: Input }],
    offsetX: [{ type: Input }],
    offsetY: [{ type: Input }],
    scale: [{ type: Input }],
    rotateWithView: [{ type: Input }],
    rotation: [{ type: Input }],
    text: [{ type: Input }],
    textAlign: [{ type: Input }],
    textBaseLine: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    StyleTextComponent.prototype.instance;
    /** @type {?} */
    StyleTextComponent.prototype.componentType;
    /** @type {?} */
    StyleTextComponent.prototype.font;
    /** @type {?} */
    StyleTextComponent.prototype.offsetX;
    /** @type {?} */
    StyleTextComponent.prototype.offsetY;
    /** @type {?} */
    StyleTextComponent.prototype.scale;
    /** @type {?} */
    StyleTextComponent.prototype.rotateWithView;
    /** @type {?} */
    StyleTextComponent.prototype.rotation;
    /** @type {?} */
    StyleTextComponent.prototype.text;
    /** @type {?} */
    StyleTextComponent.prototype.textAlign;
    /** @type {?} */
    StyleTextComponent.prototype.textBaseLine;
    /**
     * @type {?}
     * @private
     */
    StyleTextComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StyleStrokeComponent {
    /**
     * @param {?} styleHost
     * @param {?} styleCircleHost
     * @param {?} styleTextHost
     */
    constructor(styleHost, styleCircleHost, styleTextHost) {
        if (!styleHost) {
            throw new Error('aol-style-stroke must be a descendant of aol-style');
        }
        if (!!styleTextHost) {
            this.host = styleTextHost;
        }
        else if (!!styleCircleHost) {
            this.host = styleCircleHost;
        }
        else {
            this.host = styleHost;
        }
        // console.log('creating aol-style-stroke with: ', this);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('creating ol.style.Stroke instance with: ', this);
        this.instance = new Stroke(this);
        switch (this.host.componentType) {
            case 'style':
                this.host.instance.setStroke(this.instance);
                // console.log('setting ol.style instance\'s stroke:', this.host);
                break;
            case 'style-text':
                this.host.instance.setStroke(this.instance);
                break;
            case 'style-circle':
                this.host.stroke = this.instance;
                // console.log('setting ol.style.circle instance\'s stroke:', this.host);
                break;
            default:
                throw new Error('unknown host type: ' + this.host);
            // break;
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.instance) {
            return;
        }
        if (changes.color) {
            this.instance.setColor(changes.color.currentValue);
        }
        if (changes.lineCap) {
            this.instance.setLineCap(changes.lineCap.currentValue);
        }
        if (changes.lineDash) {
            this.instance.setLineDash(changes.lineDash.currentValue);
        }
        if (changes.lineJoin) {
            this.instance.setLineJoin(changes.lineJoin.currentValue);
        }
        if (changes.miterLimit) {
            this.instance.setMiterLimit(changes.miterLimit.currentValue);
        }
        if (changes.width) {
            this.instance.setWidth(changes.width.currentValue);
        }
        this.host.update();
        // console.log('changes detected in aol-style-stroke, setting new properties: ', changes);
    }
}
StyleStrokeComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-style-stroke',
                template: `
    <div class="aol-style-stroke"></div>
  `
            }] }
];
/** @nocollapse */
StyleStrokeComponent.ctorParameters = () => [
    { type: StyleComponent, decorators: [{ type: Optional }] },
    { type: StyleCircleComponent, decorators: [{ type: Optional }] },
    { type: StyleTextComponent, decorators: [{ type: Optional }] }
];
StyleStrokeComponent.propDecorators = {
    color: [{ type: Input }],
    lineCap: [{ type: Input }],
    lineDash: [{ type: Input }],
    lineJoin: [{ type: Input }],
    miterLimit: [{ type: Input }],
    width: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    StyleStrokeComponent.prototype.instance;
    /**
     * @type {?}
     * @private
     */
    StyleStrokeComponent.prototype.host;
    /** @type {?} */
    StyleStrokeComponent.prototype.color;
    /** @type {?} */
    StyleStrokeComponent.prototype.lineCap;
    /** @type {?} */
    StyleStrokeComponent.prototype.lineDash;
    /** @type {?} */
    StyleStrokeComponent.prototype.lineJoin;
    /** @type {?} */
    StyleStrokeComponent.prototype.miterLimit;
    /** @type {?} */
    StyleStrokeComponent.prototype.width;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StyleIconComponent {
    /**
     * @param {?} host
     */
    constructor(host) {
        this.host = host;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('creating ol.style.Icon instance with: ', this);
        this.instance = new Icon(this);
        this.host.instance.setImage(this.instance);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.instance) {
            return;
        }
        if (changes.opacity) {
            this.instance.setOpacity(changes.opacity.currentValue);
        }
        if (changes.rotation) {
            this.instance.setRotation(changes.rotation.currentValue);
        }
        if (changes.scale) {
            this.instance.setScale(changes.scale.currentValue);
        }
        if (changes.src) {
            this.instance = new Icon(this);
            this.host.instance.setImage(this.instance);
        }
        this.host.update();
        // console.log('changes detected in aol-style-icon: ', changes);
    }
}
StyleIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-style-icon',
                template: `
    <div class="aol-style-icon"></div>
  `
            }] }
];
/** @nocollapse */
StyleIconComponent.ctorParameters = () => [
    { type: StyleComponent, decorators: [{ type: Host }] }
];
StyleIconComponent.propDecorators = {
    anchor: [{ type: Input }],
    anchorXUnits: [{ type: Input }],
    anchorYUnits: [{ type: Input }],
    anchorOrigin: [{ type: Input }],
    color: [{ type: Input }],
    crossOrigin: [{ type: Input }],
    img: [{ type: Input }],
    offset: [{ type: Input }],
    offsetOrigin: [{ type: Input }],
    opacity: [{ type: Input }],
    scale: [{ type: Input }],
    snapToPixel: [{ type: Input }],
    rotateWithView: [{ type: Input }],
    rotation: [{ type: Input }],
    size: [{ type: Input }],
    imgSize: [{ type: Input }],
    src: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    StyleIconComponent.prototype.instance;
    /** @type {?} */
    StyleIconComponent.prototype.anchor;
    /** @type {?} */
    StyleIconComponent.prototype.anchorXUnits;
    /** @type {?} */
    StyleIconComponent.prototype.anchorYUnits;
    /** @type {?} */
    StyleIconComponent.prototype.anchorOrigin;
    /** @type {?} */
    StyleIconComponent.prototype.color;
    /** @type {?} */
    StyleIconComponent.prototype.crossOrigin;
    /** @type {?} */
    StyleIconComponent.prototype.img;
    /** @type {?} */
    StyleIconComponent.prototype.offset;
    /** @type {?} */
    StyleIconComponent.prototype.offsetOrigin;
    /** @type {?} */
    StyleIconComponent.prototype.opacity;
    /** @type {?} */
    StyleIconComponent.prototype.scale;
    /** @type {?} */
    StyleIconComponent.prototype.snapToPixel;
    /** @type {?} */
    StyleIconComponent.prototype.rotateWithView;
    /** @type {?} */
    StyleIconComponent.prototype.rotation;
    /** @type {?} */
    StyleIconComponent.prototype.size;
    /** @type {?} */
    StyleIconComponent.prototype.imgSize;
    /** @type {?} */
    StyleIconComponent.prototype.src;
    /**
     * @type {?}
     * @private
     */
    StyleIconComponent.prototype.host;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StyleFillComponent {
    /**
     * @param {?} styleHost
     * @param {?} styleCircleHost
     * @param {?} styleTextHost
     */
    constructor(styleHost, styleCircleHost, styleTextHost) {
        if (!styleHost) {
            throw new Error('aol-style-stroke must be a descendant of aol-style');
        }
        if (!!styleTextHost) {
            this.host = styleTextHost;
        }
        else if (!!styleCircleHost) {
            this.host = styleCircleHost;
        }
        else {
            this.host = styleHost;
        }
        // console.log('creating aol-style-fill with: ', this);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('creating ol.style.Fill instance with: ', this);
        this.instance = new Fill(this);
        switch (this.host.componentType) {
            case 'style':
                this.host.instance.setFill(this.instance);
                // console.log('setting ol.style instance\'s fill:', this.host);
                break;
            case 'style-text':
                this.host.instance.setFill(this.instance);
                break;
            case 'style-circle':
                this.host.fill = this.instance;
                // console.log('setting ol.style.circle instance\'s fill:', this.host);
                break;
            default:
                throw new Error('unknown host type: ' + this.host);
            // break;
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.instance) {
            return;
        }
        if (changes.color) {
            this.instance.setColor(changes.color.currentValue);
        }
        this.host.update();
        // console.log('changes detected in aol-style-fill, setting new color: ', changes);
    }
}
StyleFillComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-style-fill',
                template: `
    <div class="aol-style-fill"></div>
  `
            }] }
];
/** @nocollapse */
StyleFillComponent.ctorParameters = () => [
    { type: StyleComponent, decorators: [{ type: Optional }] },
    { type: StyleCircleComponent, decorators: [{ type: Optional }] },
    { type: StyleTextComponent, decorators: [{ type: Optional }] }
];
StyleFillComponent.propDecorators = {
    color: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    StyleFillComponent.prototype.host;
    /** @type {?} */
    StyleFillComponent.prototype.instance;
    /** @type {?} */
    StyleFillComponent.prototype.color;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DefaultControlComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('ol.control.defaults init: ', this);
        this.instance = defaults(this);
        this.instance.forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => this.map.instance.addControl(c)));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('removing aol-control-defaults');
        this.instance.forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => this.map.instance.removeControl(c)));
    }
}
DefaultControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-control-defaults',
                template: ''
            }] }
];
/** @nocollapse */
DefaultControlComponent.ctorParameters = () => [
    { type: MapComponent }
];
DefaultControlComponent.propDecorators = {
    attribution: [{ type: Input }],
    attributionOptions: [{ type: Input }],
    rotate: [{ type: Input }],
    rotateOptions: [{ type: Input }],
    zoom: [{ type: Input }],
    zoomOptions: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DefaultControlComponent.prototype.instance;
    /** @type {?} */
    DefaultControlComponent.prototype.attribution;
    /** @type {?} */
    DefaultControlComponent.prototype.attributionOptions;
    /** @type {?} */
    DefaultControlComponent.prototype.rotate;
    /** @type {?} */
    DefaultControlComponent.prototype.rotateOptions;
    /** @type {?} */
    DefaultControlComponent.prototype.zoom;
    /** @type {?} */
    DefaultControlComponent.prototype.zoomOptions;
    /**
     * @type {?}
     * @private
     */
    DefaultControlComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ControlComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        this.componentType = 'control';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.content) {
            this.element = this.content.elementRef.nativeElement;
            this.instance = new Control(this);
            this.map.instance.addControl(this.instance);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.instance) {
            this.map.instance.removeControl(this.instance);
        }
    }
}
ControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-control',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
ControlComponent.ctorParameters = () => [
    { type: MapComponent }
];
ControlComponent.propDecorators = {
    content: [{ type: ContentChild, args: [ContentComponent, { static: true },] }]
};
if (false) {
    /** @type {?} */
    ControlComponent.prototype.componentType;
    /** @type {?} */
    ControlComponent.prototype.instance;
    /** @type {?} */
    ControlComponent.prototype.element;
    /** @type {?} */
    ControlComponent.prototype.content;
    /**
     * @type {?}
     * @private
     */
    ControlComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ControlAttributionComponent {
    /**
     * @param {?} map
     * @param {?} element
     */
    constructor(map, element) {
        this.map = map;
        this.element = element;
        this.componentType = 'control';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.target = this.element.nativeElement;
        // console.log('ol.control.Attribution init: ', this);
        this.instance = new Attribution(this);
        this.map.instance.addControl(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('removing aol-control-attribution');
        this.map.instance.removeControl(this.instance);
    }
}
ControlAttributionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-control-attribution',
                template: ``
            }] }
];
/** @nocollapse */
ControlAttributionComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: ElementRef }
];
ControlAttributionComponent.propDecorators = {
    collapsible: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ControlAttributionComponent.prototype.componentType;
    /** @type {?} */
    ControlAttributionComponent.prototype.instance;
    /** @type {?} */
    ControlAttributionComponent.prototype.target;
    /** @type {?} */
    ControlAttributionComponent.prototype.collapsible;
    /**
     * @type {?}
     * @private
     */
    ControlAttributionComponent.prototype.map;
    /**
     * @type {?}
     * @private
     */
    ControlAttributionComponent.prototype.element;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ControlFullScreenComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        // console.log('instancing aol-control-fullscreen');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new FullScreen(this);
        this.map.instance.addControl(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('removing aol-control-fullscreen');
        this.map.instance.removeControl(this.instance);
    }
}
ControlFullScreenComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-control-fullscreen',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
ControlFullScreenComponent.ctorParameters = () => [
    { type: MapComponent }
];
ControlFullScreenComponent.propDecorators = {
    className: [{ type: Input }],
    label: [{ type: Input }],
    labelActive: [{ type: Input }],
    tipLabel: [{ type: Input }],
    keys: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ControlFullScreenComponent.prototype.instance;
    /** @type {?} */
    ControlFullScreenComponent.prototype.className;
    /** @type {?} */
    ControlFullScreenComponent.prototype.label;
    /** @type {?} */
    ControlFullScreenComponent.prototype.labelActive;
    /** @type {?} */
    ControlFullScreenComponent.prototype.tipLabel;
    /** @type {?} */
    ControlFullScreenComponent.prototype.keys;
    /**
     * @type {?}
     * @private
     */
    ControlFullScreenComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ControlMousePositionComponent {
    /**
     * @param {?} map
     * @param {?} element
     */
    constructor(map, element) {
        this.map = map;
        this.element = element;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.target = this.element.nativeElement;
        // console.log('ol.control.MousePosition init: ', this);
        this.instance = new MousePosition(this);
        this.map.instance.addControl(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('removing aol-control-mouseposition');
        this.map.instance.removeControl(this.instance);
    }
}
ControlMousePositionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-control-mouseposition',
                template: ``
            }] }
];
/** @nocollapse */
ControlMousePositionComponent.ctorParameters = () => [
    { type: MapComponent },
    { type: ElementRef }
];
ControlMousePositionComponent.propDecorators = {
    coordinateFormat: [{ type: Input }],
    projection: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ControlMousePositionComponent.prototype.instance;
    /** @type {?} */
    ControlMousePositionComponent.prototype.coordinateFormat;
    /** @type {?} */
    ControlMousePositionComponent.prototype.projection;
    /** @type {?} */
    ControlMousePositionComponent.prototype.target;
    /**
     * @type {?}
     * @private
     */
    ControlMousePositionComponent.prototype.map;
    /**
     * @type {?}
     * @private
     */
    ControlMousePositionComponent.prototype.element;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ControlOverviewMapComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new OverviewMap(this);
        this.map.instance.addControl(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeControl(this.instance);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.instance != null && changes.hasOwnProperty('view')) {
            this.reloadInstance();
        }
    }
    /**
     * @private
     * @return {?}
     */
    reloadInstance() {
        this.map.instance.removeControl(this.instance);
        this.instance = new OverviewMap(this);
        this.map.instance.addControl(this.instance);
    }
}
ControlOverviewMapComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-control-overviewmap',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
ControlOverviewMapComponent.ctorParameters = () => [
    { type: MapComponent }
];
ControlOverviewMapComponent.propDecorators = {
    collapsed: [{ type: Input }],
    collapseLabel: [{ type: Input }],
    collapsible: [{ type: Input }],
    label: [{ type: Input }],
    layers: [{ type: Input }],
    target: [{ type: Input }],
    tipLabel: [{ type: Input }],
    view: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ControlOverviewMapComponent.prototype.instance;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.collapsed;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.collapseLabel;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.collapsible;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.label;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.layers;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.target;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.tipLabel;
    /** @type {?} */
    ControlOverviewMapComponent.prototype.view;
    /**
     * @type {?}
     * @private
     */
    ControlOverviewMapComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ControlRotateComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        // console.log('instancing aol-control-rotate');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new Rotate(this);
        this.map.instance.addControl(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('removing aol-control-rotate');
        this.map.instance.removeControl(this.instance);
    }
}
ControlRotateComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-control-rotate',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
ControlRotateComponent.ctorParameters = () => [
    { type: MapComponent }
];
ControlRotateComponent.propDecorators = {
    className: [{ type: Input }],
    label: [{ type: Input }],
    tipLabel: [{ type: Input }],
    duration: [{ type: Input }],
    autoHide: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ControlRotateComponent.prototype.instance;
    /** @type {?} */
    ControlRotateComponent.prototype.className;
    /** @type {?} */
    ControlRotateComponent.prototype.label;
    /** @type {?} */
    ControlRotateComponent.prototype.tipLabel;
    /** @type {?} */
    ControlRotateComponent.prototype.duration;
    /** @type {?} */
    ControlRotateComponent.prototype.autoHide;
    /**
     * @type {?}
     * @private
     */
    ControlRotateComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ControlScaleLineComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        // console.log('instancing aol-control-scaleline');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new ScaleLine(this);
        this.map.instance.addControl(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('removing aol-control-scaleline');
        this.map.instance.removeControl(this.instance);
    }
}
ControlScaleLineComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-control-scaleline',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
ControlScaleLineComponent.ctorParameters = () => [
    { type: MapComponent }
];
ControlScaleLineComponent.propDecorators = {
    units: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ControlScaleLineComponent.prototype.instance;
    /** @type {?} */
    ControlScaleLineComponent.prototype.units;
    /**
     * @type {?}
     * @private
     */
    ControlScaleLineComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ControlZoomComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        // console.log('instancing aol-control-zoom');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new Zoom(this);
        this.map.instance.addControl(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('removing aol-control-zoom');
        this.map.instance.removeControl(this.instance);
    }
}
ControlZoomComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-control-zoom',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
ControlZoomComponent.ctorParameters = () => [
    { type: MapComponent }
];
ControlZoomComponent.propDecorators = {
    duration: [{ type: Input }],
    zoomInLabel: [{ type: Input }],
    zoomOutLabel: [{ type: Input }],
    zoomInTipLabel: [{ type: Input }],
    zoomOutTipLabel: [{ type: Input }],
    delta: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ControlZoomComponent.prototype.instance;
    /** @type {?} */
    ControlZoomComponent.prototype.duration;
    /** @type {?} */
    ControlZoomComponent.prototype.zoomInLabel;
    /** @type {?} */
    ControlZoomComponent.prototype.zoomOutLabel;
    /** @type {?} */
    ControlZoomComponent.prototype.zoomInTipLabel;
    /** @type {?} */
    ControlZoomComponent.prototype.zoomOutTipLabel;
    /** @type {?} */
    ControlZoomComponent.prototype.delta;
    /**
     * @type {?}
     * @private
     */
    ControlZoomComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ControlZoomSliderComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        // console.log('instancing aol-control-zoomslider');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new ZoomSlider(this);
        this.map.instance.addControl(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('removing aol-control-zoomslider');
        this.map.instance.removeControl(this.instance);
    }
}
ControlZoomSliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-control-zoomslider',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
ControlZoomSliderComponent.ctorParameters = () => [
    { type: MapComponent }
];
ControlZoomSliderComponent.propDecorators = {
    className: [{ type: Input }],
    duration: [{ type: Input }],
    maxResolution: [{ type: Input }],
    minResolution: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ControlZoomSliderComponent.prototype.instance;
    /** @type {?} */
    ControlZoomSliderComponent.prototype.className;
    /** @type {?} */
    ControlZoomSliderComponent.prototype.duration;
    /** @type {?} */
    ControlZoomSliderComponent.prototype.maxResolution;
    /** @type {?} */
    ControlZoomSliderComponent.prototype.minResolution;
    /**
     * @type {?}
     * @private
     */
    ControlZoomSliderComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ControlZoomToExtentComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        // console.log('instancing aol-control-zoomtoextent');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new ZoomToExtent(this);
        this.map.instance.addControl(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('removing aol-control-zoomtoextent');
        this.map.instance.removeControl(this.instance);
    }
}
ControlZoomToExtentComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-control-zoomtoextent',
                template: `
    <ng-content></ng-content>
  `
            }] }
];
/** @nocollapse */
ControlZoomToExtentComponent.ctorParameters = () => [
    { type: MapComponent }
];
ControlZoomToExtentComponent.propDecorators = {
    className: [{ type: Input }],
    label: [{ type: Input }],
    tipLabel: [{ type: Input }],
    extent: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ControlZoomToExtentComponent.prototype.instance;
    /** @type {?} */
    ControlZoomToExtentComponent.prototype.className;
    /** @type {?} */
    ControlZoomToExtentComponent.prototype.label;
    /** @type {?} */
    ControlZoomToExtentComponent.prototype.tipLabel;
    /** @type {?} */
    ControlZoomToExtentComponent.prototype.extent;
    /**
     * @type {?}
     * @private
     */
    ControlZoomToExtentComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormatMVTComponent extends FormatComponent {
    constructor() {
        super();
        this.instance = new MVT(this);
    }
}
FormatMVTComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-format-mvt',
                template: '',
                providers: [{ provide: FormatComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FormatMVTComponent)) }]
            }] }
];
/** @nocollapse */
FormatMVTComponent.ctorParameters = () => [];
FormatMVTComponent.propDecorators = {
    featureClass: [{ type: Input }],
    geometryName: [{ type: Input }],
    layerName: [{ type: Input }],
    layers: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FormatMVTComponent.prototype.instance;
    /** @type {?} */
    FormatMVTComponent.prototype.featureClass;
    /** @type {?} */
    FormatMVTComponent.prototype.geometryName;
    /** @type {?} */
    FormatMVTComponent.prototype.layerName;
    /** @type {?} */
    FormatMVTComponent.prototype.layers;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DefaultInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = defaults$1();
        this.instance.forEach((/**
         * @param {?} i
         * @return {?}
         */
        i => this.map.instance.addInteraction(i)));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.instance.forEach((/**
         * @param {?} i
         * @return {?}
         */
        i => this.map.instance.removeInteraction(i)));
    }
}
DefaultInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-default',
                template: ''
            }] }
];
/** @nocollapse */
DefaultInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
if (false) {
    /** @type {?} */
    DefaultInteractionComponent.prototype.instance;
    /**
     * @type {?}
     * @private
     */
    DefaultInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DoubleClickZoomInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new DoubleClickZoom(this);
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
DoubleClickZoomInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-doubleclickzoom',
                template: ''
            }] }
];
/** @nocollapse */
DoubleClickZoomInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
DoubleClickZoomInteractionComponent.propDecorators = {
    duration: [{ type: Input }],
    delta: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DoubleClickZoomInteractionComponent.prototype.instance;
    /** @type {?} */
    DoubleClickZoomInteractionComponent.prototype.duration;
    /** @type {?} */
    DoubleClickZoomInteractionComponent.prototype.delta;
    /**
     * @type {?}
     * @private
     */
    DoubleClickZoomInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragAndDropInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new DragAndDrop(this);
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
DragAndDropInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-draganddrop',
                template: ''
            }] }
];
/** @nocollapse */
DragAndDropInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
DragAndDropInteractionComponent.propDecorators = {
    formatConstructors: [{ type: Input }],
    projection: [{ type: Input }],
    target: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DragAndDropInteractionComponent.prototype.instance;
    /** @type {?} */
    DragAndDropInteractionComponent.prototype.formatConstructors;
    /** @type {?} */
    DragAndDropInteractionComponent.prototype.projection;
    /** @type {?} */
    DragAndDropInteractionComponent.prototype.target;
    /**
     * @type {?}
     * @private
     */
    DragAndDropInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragBoxInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new DragBox(this);
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
DragBoxInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-dragbox',
                template: ''
            }] }
];
/** @nocollapse */
DragBoxInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
DragBoxInteractionComponent.propDecorators = {
    className: [{ type: Input }],
    condition: [{ type: Input }],
    boxEndCondition: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DragBoxInteractionComponent.prototype.instance;
    /** @type {?} */
    DragBoxInteractionComponent.prototype.className;
    /** @type {?} */
    DragBoxInteractionComponent.prototype.condition;
    /** @type {?} */
    DragBoxInteractionComponent.prototype.boxEndCondition;
    /**
     * @type {?}
     * @private
     */
    DragBoxInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragPanInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new DragPan(this);
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
DragPanInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-dragpan',
                template: ''
            }] }
];
/** @nocollapse */
DragPanInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
DragPanInteractionComponent.propDecorators = {
    condition: [{ type: Input }],
    kinetic: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DragPanInteractionComponent.prototype.instance;
    /** @type {?} */
    DragPanInteractionComponent.prototype.condition;
    /** @type {?} */
    DragPanInteractionComponent.prototype.kinetic;
    /**
     * @type {?}
     * @private
     */
    DragPanInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragRotateInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new DragRotate(this);
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
DragRotateInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-dragrotate',
                template: ''
            }] }
];
/** @nocollapse */
DragRotateInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
DragRotateInteractionComponent.propDecorators = {
    condition: [{ type: Input }],
    duration: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DragRotateInteractionComponent.prototype.instance;
    /** @type {?} */
    DragRotateInteractionComponent.prototype.condition;
    /** @type {?} */
    DragRotateInteractionComponent.prototype.duration;
    /**
     * @type {?}
     * @private
     */
    DragRotateInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragRotateAndZoomInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new DragRotateAndZoom(this);
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
DragRotateAndZoomInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-dragrotateandzoom',
                template: ''
            }] }
];
/** @nocollapse */
DragRotateAndZoomInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
DragRotateAndZoomInteractionComponent.propDecorators = {
    condition: [{ type: Input }],
    duration: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DragRotateAndZoomInteractionComponent.prototype.instance;
    /** @type {?} */
    DragRotateAndZoomInteractionComponent.prototype.condition;
    /** @type {?} */
    DragRotateAndZoomInteractionComponent.prototype.duration;
    /**
     * @type {?}
     * @private
     */
    DragRotateAndZoomInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragZoomInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new DragZoom(this);
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
DragZoomInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-dragzoom',
                template: ''
            }] }
];
/** @nocollapse */
DragZoomInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
DragZoomInteractionComponent.propDecorators = {
    className: [{ type: Input }],
    condition: [{ type: Input }],
    duration: [{ type: Input }],
    out: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DragZoomInteractionComponent.prototype.instance;
    /** @type {?} */
    DragZoomInteractionComponent.prototype.className;
    /** @type {?} */
    DragZoomInteractionComponent.prototype.condition;
    /** @type {?} */
    DragZoomInteractionComponent.prototype.duration;
    /** @type {?} */
    DragZoomInteractionComponent.prototype.out;
    /**
     * @type {?}
     * @private
     */
    DragZoomInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MouseWheelZoomInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new MouseWheelZoom(this);
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
MouseWheelZoomInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-mousewheelzoom',
                template: ''
            }] }
];
/** @nocollapse */
MouseWheelZoomInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
MouseWheelZoomInteractionComponent.propDecorators = {
    duration: [{ type: Input }],
    timeout: [{ type: Input }],
    useAnchor: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    MouseWheelZoomInteractionComponent.prototype.instance;
    /** @type {?} */
    MouseWheelZoomInteractionComponent.prototype.duration;
    /** @type {?} */
    MouseWheelZoomInteractionComponent.prototype.timeout;
    /** @type {?} */
    MouseWheelZoomInteractionComponent.prototype.useAnchor;
    /**
     * @type {?}
     * @private
     */
    MouseWheelZoomInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PinchZoomInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new PinchZoom(this);
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
PinchZoomInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-pinchzoom',
                template: ''
            }] }
];
/** @nocollapse */
PinchZoomInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
PinchZoomInteractionComponent.propDecorators = {
    duration: [{ type: Input }],
    constrainResolution: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    PinchZoomInteractionComponent.prototype.instance;
    /** @type {?} */
    PinchZoomInteractionComponent.prototype.duration;
    /** @type {?} */
    PinchZoomInteractionComponent.prototype.constrainResolution;
    /**
     * @type {?}
     * @private
     */
    PinchZoomInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DrawInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        this.olChange = new EventEmitter();
        this.olChangeActive = new EventEmitter();
        this.drawEnd = new EventEmitter();
        this.drawStart = new EventEmitter();
        this.propertyChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new Draw(this);
        this.instance.on('change', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.olChange.emit(event)));
        this.instance.on('change:active', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.olChangeActive.emit(event)));
        this.instance.on('drawend', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.drawEnd.emit(event)));
        this.instance.on('drawstart', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.drawStart.emit(event)));
        this.instance.on('propertychange', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.propertyChange.emit(event)));
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
DrawInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-draw',
                template: ''
            }] }
];
/** @nocollapse */
DrawInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
DrawInteractionComponent.propDecorators = {
    clickTolerance: [{ type: Input }],
    features: [{ type: Input }],
    source: [{ type: Input }],
    snapTolerance: [{ type: Input }],
    type: [{ type: Input }],
    maxPoints: [{ type: Input }],
    minPoints: [{ type: Input }],
    finishCondition: [{ type: Input }],
    style: [{ type: Input }],
    geometryFunction: [{ type: Input }],
    geometryName: [{ type: Input }],
    condition: [{ type: Input }],
    freehandCondition: [{ type: Input }],
    freehand: [{ type: Input }],
    wrapX: [{ type: Input }],
    olChange: [{ type: Output }],
    olChangeActive: [{ type: Output }],
    drawEnd: [{ type: Output }],
    drawStart: [{ type: Output }],
    propertyChange: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    DrawInteractionComponent.prototype.instance;
    /** @type {?} */
    DrawInteractionComponent.prototype.clickTolerance;
    /** @type {?} */
    DrawInteractionComponent.prototype.features;
    /** @type {?} */
    DrawInteractionComponent.prototype.source;
    /** @type {?} */
    DrawInteractionComponent.prototype.snapTolerance;
    /** @type {?} */
    DrawInteractionComponent.prototype.type;
    /** @type {?} */
    DrawInteractionComponent.prototype.maxPoints;
    /** @type {?} */
    DrawInteractionComponent.prototype.minPoints;
    /** @type {?} */
    DrawInteractionComponent.prototype.finishCondition;
    /** @type {?} */
    DrawInteractionComponent.prototype.style;
    /** @type {?} */
    DrawInteractionComponent.prototype.geometryFunction;
    /** @type {?} */
    DrawInteractionComponent.prototype.geometryName;
    /** @type {?} */
    DrawInteractionComponent.prototype.condition;
    /** @type {?} */
    DrawInteractionComponent.prototype.freehandCondition;
    /** @type {?} */
    DrawInteractionComponent.prototype.freehand;
    /** @type {?} */
    DrawInteractionComponent.prototype.wrapX;
    /** @type {?} */
    DrawInteractionComponent.prototype.olChange;
    /** @type {?} */
    DrawInteractionComponent.prototype.olChangeActive;
    /** @type {?} */
    DrawInteractionComponent.prototype.drawEnd;
    /** @type {?} */
    DrawInteractionComponent.prototype.drawStart;
    /** @type {?} */
    DrawInteractionComponent.prototype.propertyChange;
    /**
     * @type {?}
     * @private
     */
    DrawInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SelectInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        this.olChange = new EventEmitter();
        this.olSelect = new EventEmitter();
        this.propertyChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new Select(this);
        this.instance.on('change', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.olChange.emit(event)));
        this.instance.on('select', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.olSelect.emit(event)));
        this.instance.on('propertychange', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.propertyChange.emit(event)));
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
SelectInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-select',
                template: ''
            }] }
];
/** @nocollapse */
SelectInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
SelectInteractionComponent.propDecorators = {
    addCondition: [{ type: Input }],
    condition: [{ type: Input }],
    layers: [{ type: Input }],
    style: [{ type: Input }],
    removeCondition: [{ type: Input }],
    toggleCondition: [{ type: Input }],
    multi: [{ type: Input }],
    features: [{ type: Input }],
    filter: [{ type: Input }],
    wrapX: [{ type: Input }],
    olChange: [{ type: Output }],
    olSelect: [{ type: Output }],
    propertyChange: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SelectInteractionComponent.prototype.instance;
    /** @type {?} */
    SelectInteractionComponent.prototype.addCondition;
    /** @type {?} */
    SelectInteractionComponent.prototype.condition;
    /** @type {?} */
    SelectInteractionComponent.prototype.layers;
    /** @type {?} */
    SelectInteractionComponent.prototype.style;
    /** @type {?} */
    SelectInteractionComponent.prototype.removeCondition;
    /** @type {?} */
    SelectInteractionComponent.prototype.toggleCondition;
    /** @type {?} */
    SelectInteractionComponent.prototype.multi;
    /** @type {?} */
    SelectInteractionComponent.prototype.features;
    /** @type {?} */
    SelectInteractionComponent.prototype.filter;
    /** @type {?} */
    SelectInteractionComponent.prototype.wrapX;
    /** @type {?} */
    SelectInteractionComponent.prototype.olChange;
    /** @type {?} */
    SelectInteractionComponent.prototype.olSelect;
    /** @type {?} */
    SelectInteractionComponent.prototype.propertyChange;
    /**
     * @type {?}
     * @private
     */
    SelectInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModifyInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        this.modifyEnd = new EventEmitter();
        this.modifyStart = new EventEmitter();
        this.olChange = new EventEmitter();
        this.olChangeActive = new EventEmitter();
        this.propertyChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new Modify(this);
        this.instance.on('change', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.olChange.emit(event)));
        this.instance.on('change:active', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.olChangeActive.emit(event)));
        this.instance.on('propertychange', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.propertyChange.emit(event)));
        this.instance.on('modifyend', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.modifyEnd.emit(event)));
        this.instance.on('modifystart', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.modifyStart.emit(event)));
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
ModifyInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-modify',
                template: ''
            }] }
];
/** @nocollapse */
ModifyInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
ModifyInteractionComponent.propDecorators = {
    condition: [{ type: Input }],
    deleteCondition: [{ type: Input }],
    pixelTolerance: [{ type: Input }],
    style: [{ type: Input }],
    features: [{ type: Input }],
    wrapX: [{ type: Input }],
    source: [{ type: Input }],
    modifyEnd: [{ type: Output }],
    modifyStart: [{ type: Output }],
    olChange: [{ type: Output }],
    olChangeActive: [{ type: Output }],
    propertyChange: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    ModifyInteractionComponent.prototype.instance;
    /** @type {?} */
    ModifyInteractionComponent.prototype.condition;
    /** @type {?} */
    ModifyInteractionComponent.prototype.deleteCondition;
    /** @type {?} */
    ModifyInteractionComponent.prototype.pixelTolerance;
    /** @type {?} */
    ModifyInteractionComponent.prototype.style;
    /** @type {?} */
    ModifyInteractionComponent.prototype.features;
    /** @type {?} */
    ModifyInteractionComponent.prototype.wrapX;
    /** @type {?} */
    ModifyInteractionComponent.prototype.source;
    /** @type {?} */
    ModifyInteractionComponent.prototype.modifyEnd;
    /** @type {?} */
    ModifyInteractionComponent.prototype.modifyStart;
    /** @type {?} */
    ModifyInteractionComponent.prototype.olChange;
    /** @type {?} */
    ModifyInteractionComponent.prototype.olChangeActive;
    /** @type {?} */
    ModifyInteractionComponent.prototype.propertyChange;
    /**
     * @type {?}
     * @private
     */
    ModifyInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TranslateInteractionComponent {
    /**
     * @param {?} map
     */
    constructor(map) {
        this.map = map;
        this.olChange = new EventEmitter();
        this.propertyChange = new EventEmitter();
        this.translateEnd = new EventEmitter();
        this.translateStart = new EventEmitter();
        this.translating = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new Translate(this);
        this.instance.on('change', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.olChange.emit(event)));
        this.instance.on('propertychange', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.propertyChange.emit(event)));
        this.instance.on('translateend', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.translateEnd.emit(event)));
        this.instance.on('translatestart', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.translateStart.emit(event)));
        this.instance.on('translating', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.translating.emit(event)));
        this.map.instance.addInteraction(this.instance);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.map.instance.removeInteraction(this.instance);
    }
}
TranslateInteractionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-interaction-translate',
                template: ''
            }] }
];
/** @nocollapse */
TranslateInteractionComponent.ctorParameters = () => [
    { type: MapComponent }
];
TranslateInteractionComponent.propDecorators = {
    features: [{ type: Input }],
    layers: [{ type: Input }],
    hitTolerance: [{ type: Input }],
    olChange: [{ type: Output }],
    propertyChange: [{ type: Output }],
    translateEnd: [{ type: Output }],
    translateStart: [{ type: Output }],
    translating: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    TranslateInteractionComponent.prototype.instance;
    /** @type {?} */
    TranslateInteractionComponent.prototype.features;
    /** @type {?} */
    TranslateInteractionComponent.prototype.layers;
    /** @type {?} */
    TranslateInteractionComponent.prototype.hitTolerance;
    /** @type {?} */
    TranslateInteractionComponent.prototype.olChange;
    /** @type {?} */
    TranslateInteractionComponent.prototype.propertyChange;
    /** @type {?} */
    TranslateInteractionComponent.prototype.translateEnd;
    /** @type {?} */
    TranslateInteractionComponent.prototype.translateStart;
    /** @type {?} */
    TranslateInteractionComponent.prototype.translating;
    /**
     * @type {?}
     * @private
     */
    TranslateInteractionComponent.prototype.map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AttributionComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.html = this.elementRef.nativeElement.innerHTML;
        this.instance = new Attribution(this);
    }
}
AttributionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-attribution',
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
AttributionComponent.ctorParameters = () => [
    { type: ElementRef }
];
if (false) {
    /** @type {?} */
    AttributionComponent.prototype.instance;
    /** @type {?} */
    AttributionComponent.prototype.html;
    /**
     * @type {?}
     * @private
     */
    AttributionComponent.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AttributionsComponent {
    /**
     * @param {?} source
     */
    constructor(source) {
        this.source = source;
    }
    /* we can do this at the very end */
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.attributions.length) {
            this.instance = this.attributions.map((/**
             * @param {?} cmp
             * @return {?}
             */
            cmp => cmp.instance));
            // console.log('setting attributions:', this.instance);
            this.source.instance.setAttributions(this.instance);
        }
    }
}
AttributionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-attributions',
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
AttributionsComponent.ctorParameters = () => [
    { type: SourceComponent, decorators: [{ type: Host }] }
];
AttributionsComponent.propDecorators = {
    attributions: [{ type: ContentChildren, args: [AttributionComponent,] }]
};
if (false) {
    /** @type {?} */
    AttributionsComponent.prototype.instance;
    /** @type {?} */
    AttributionsComponent.prototype.attributions;
    /**
     * @type {?}
     * @private
     */
    AttributionsComponent.prototype.source;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SourceUTFGridComponent extends SourceComponent {
    /**
     * @param {?} layer
     */
    constructor(layer) {
        super(layer);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = new UTFGrid(this);
        this.host.instance.setSource(this.instance);
    }
}
SourceUTFGridComponent.decorators = [
    { type: Component, args: [{
                selector: 'aol-source-utfgrid',
                template: `
    <ng-content></ng-content>
  `,
                providers: [{ provide: SourceComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SourceUTFGridComponent)) }]
            }] }
];
/** @nocollapse */
SourceUTFGridComponent.ctorParameters = () => [
    { type: LayerTileComponent, decorators: [{ type: Host }] }
];
SourceUTFGridComponent.propDecorators = {
    tileJSON: [{ type: Input }],
    url: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    SourceUTFGridComponent.prototype.instance;
    /** @type {?} */
    SourceUTFGridComponent.prototype.tileJSON;
    /** @type {?} */
    SourceUTFGridComponent.prototype.url;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const COMPONENTS = [
    MapComponent,
    ViewComponent,
    GraticuleComponent,
    LayerGroupComponent,
    LayerImageComponent,
    LayerTileComponent,
    LayerVectorComponent,
    LayerVectorTileComponent,
    SourceOsmComponent,
    SourceBingmapsComponent,
    SourceClusterComponent,
    SourceUTFGridComponent,
    SourceVectorComponent,
    SourceXYZComponent,
    SourceVectorTileComponent,
    SourceTileWMSComponent,
    SourceTileWMTSComponent,
    SourceTileJSONComponent,
    SourceGeoJSONComponent,
    SourceImageStaticComponent,
    SourceImageWMSComponent,
    SourceImageArcGISRestComponent,
    SourceRasterComponent,
    FeatureComponent,
    GeometryLinestringComponent,
    GeometryMultiLinestringComponent,
    GeometryMultiPointComponent,
    GeometryMultiPolygonComponent,
    GeometryPointComponent,
    GeometryPolygonComponent,
    GeometryCircleComponent,
    CoordinateComponent,
    CollectionCoordinatesComponent,
    StyleComponent,
    StyleCircleComponent,
    StyleFillComponent,
    StyleIconComponent,
    StyleStrokeComponent,
    StyleTextComponent,
    DefaultControlComponent,
    ControlComponent,
    ControlAttributionComponent,
    ControlFullScreenComponent,
    ControlMousePositionComponent,
    ControlOverviewMapComponent,
    ControlRotateComponent,
    ControlScaleLineComponent,
    ControlZoomComponent,
    ControlZoomSliderComponent,
    ControlZoomToExtentComponent,
    FormatMVTComponent,
    TileGridComponent,
    TileGridWMTSComponent,
    DefaultInteractionComponent,
    DoubleClickZoomInteractionComponent,
    DragAndDropInteractionComponent,
    DragBoxInteractionComponent,
    DragPanInteractionComponent,
    DragRotateInteractionComponent,
    DragRotateAndZoomInteractionComponent,
    DragZoomInteractionComponent,
    MouseWheelZoomInteractionComponent,
    PinchZoomInteractionComponent,
    DrawInteractionComponent,
    SelectInteractionComponent,
    ModifyInteractionComponent,
    TranslateInteractionComponent,
    OverlayComponent,
    ContentComponent,
    AttributionsComponent,
    AttributionComponent,
];
class AngularOpenlayersModule {
}
AngularOpenlayersModule.decorators = [
    { type: NgModule, args: [{
                declarations: COMPONENTS,
                imports: [CommonModule],
                exports: COMPONENTS,
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AngularOpenlayersModule, AttributionComponent, AttributionsComponent, CollectionCoordinatesComponent, ContentComponent, ControlAttributionComponent, ControlComponent, ControlFullScreenComponent, ControlMousePositionComponent, ControlOverviewMapComponent, ControlRotateComponent, ControlScaleLineComponent, ControlZoomComponent, ControlZoomSliderComponent, ControlZoomToExtentComponent, CoordinateComponent, DefaultControlComponent, DefaultInteractionComponent, DoubleClickZoomInteractionComponent, DragAndDropInteractionComponent, DragBoxInteractionComponent, DragPanInteractionComponent, DragRotateAndZoomInteractionComponent, DragRotateInteractionComponent, DragZoomInteractionComponent, DrawInteractionComponent, FeatureComponent, FormatMVTComponent, GeometryCircleComponent, GeometryLinestringComponent, GeometryMultiLinestringComponent, GeometryMultiPointComponent, GeometryMultiPolygonComponent, GeometryPointComponent, GeometryPolygonComponent, GraticuleComponent, LayerGroupComponent, LayerImageComponent, LayerTileComponent, LayerVectorComponent, LayerVectorTileComponent, MapComponent, ModifyInteractionComponent, MouseWheelZoomInteractionComponent, OverlayComponent, PinchZoomInteractionComponent, SelectInteractionComponent, SourceBingmapsComponent, SourceClusterComponent, SourceGeoJSONComponent, SourceImageArcGISRestComponent, SourceImageStaticComponent, SourceImageWMSComponent, SourceOsmComponent, SourceRasterComponent, SourceTileJSONComponent, SourceTileWMSComponent, SourceTileWMTSComponent, SourceUTFGridComponent, SourceVectorComponent, SourceVectorTileComponent, SourceXYZComponent, StyleCircleComponent, StyleComponent, StyleFillComponent, StyleIconComponent, StyleStrokeComponent, StyleTextComponent, TileGridComponent, TileGridWMTSComponent, TranslateInteractionComponent, ViewComponent, LayerComponent as a, SourceComponent as b, FormatComponent as c, SimpleGeometryComponent as d };
//# sourceMappingURL=ngx-openlayers.js.map
